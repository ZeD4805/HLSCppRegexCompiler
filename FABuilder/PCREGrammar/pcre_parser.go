// Code generated from /home/zed4805/GolandProjects/thesisGoRemake/Resources/Grammar/PCRE.g4 by ANTLR 4.9.2. DO NOT EDIT.

package parser // PCRE

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 130, 942,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 3, 2, 6, 2, 82, 10, 2, 13, 2, 14, 2, 83, 3, 2, 3, 2,
	3, 3, 3, 3, 5, 3, 90, 10, 3, 3, 3, 3, 3, 3, 3, 5, 3, 95, 10, 3, 3, 3, 5,
	3, 98, 10, 3, 3, 3, 3, 3, 3, 4, 6, 4, 103, 10, 4, 13, 4, 14, 4, 104, 3,
	5, 3, 5, 3, 5, 7, 5, 110, 10, 5, 12, 5, 14, 5, 113, 11, 5, 3, 6, 7, 6,
	116, 10, 6, 12, 6, 14, 6, 119, 11, 6, 3, 7, 3, 7, 5, 7, 123, 10, 7, 3,
	8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5,
	8, 149, 10, 8, 3, 9, 3, 9, 3, 9, 5, 9, 154, 10, 9, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 10, 6, 10, 161, 10, 10, 13, 10, 14, 10, 162, 3, 10, 3, 10, 3,
	10, 3, 10, 3, 10, 3, 10, 7, 10, 171, 10, 10, 12, 10, 14, 10, 174, 11, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 6, 10, 180, 10, 10, 13, 10, 14, 10, 181, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 6, 10, 190, 10, 10, 13, 10, 14,
	10, 191, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 7, 10, 199, 10, 10, 12, 10,
	14, 10, 202, 11, 10, 3, 10, 3, 10, 3, 10, 6, 10, 207, 10, 10, 13, 10, 14,
	10, 208, 3, 10, 3, 10, 5, 10, 213, 10, 10, 3, 11, 3, 11, 3, 11, 3, 11,
	3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3,
	11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11,
	3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 249,
	10, 11, 3, 12, 3, 12, 3, 12, 5, 12, 254, 10, 12, 3, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 276, 10, 13, 3, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3,
	14, 3, 14, 3, 14, 5, 14, 303, 10, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15,
	3, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 5, 16, 365, 10, 16, 3, 17, 6, 17, 368, 10, 17, 13, 17,
	14, 17, 369, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 400,
	10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 480, 10, 20, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 490, 10, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5,
	21, 503, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 5, 21, 516, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 530, 10, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 5, 21, 544, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 557, 10, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 569, 10, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 5, 21, 583, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 600,
	10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 617, 10, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 629,
	10, 21, 3, 21, 3, 21, 5, 21, 633, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	5, 22, 650, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5,
	22, 659, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 5, 22, 735, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 798, 10, 23, 3, 24, 3, 24, 3, 24, 3,
	24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 810, 10, 24, 3, 25,
	3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 838, 10, 25, 3, 26, 3, 26, 3, 26, 3,
	26, 3, 26, 3, 26, 3, 26, 5, 26, 847, 10, 26, 3, 27, 3, 27, 3, 28, 3, 28,
	5, 28, 853, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 867, 10, 29, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 5, 30, 895, 10, 30, 3, 31, 3, 31, 3, 32, 3, 32, 3, 32, 3,
	32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 908, 10, 32, 3, 33, 3, 33,
	3, 34, 6, 34, 913, 10, 34, 13, 34, 14, 34, 914, 3, 35, 3, 35, 3, 36, 3,
	36, 3, 37, 3, 37, 5, 37, 923, 10, 37, 3, 37, 3, 37, 3, 37, 7, 37, 928,
	10, 37, 12, 37, 14, 37, 931, 11, 37, 3, 38, 6, 38, 934, 10, 38, 13, 38,
	14, 38, 935, 3, 39, 3, 39, 3, 40, 3, 40, 3, 40, 2, 2, 41, 2, 4, 6, 8, 10,
	12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
	48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 2, 9, 8,
	2, 76, 76, 80, 80, 86, 86, 91, 91, 103, 103, 114, 114, 5, 2, 9, 9, 19,
	32, 38, 39, 4, 2, 120, 122, 129, 129, 4, 2, 120, 126, 129, 129, 3, 2, 120,
	129, 3, 2, 58, 58, 3, 2, 68, 119, 2, 1075, 2, 81, 3, 2, 2, 2, 4, 87, 3,
	2, 2, 2, 6, 102, 3, 2, 2, 2, 8, 106, 3, 2, 2, 2, 10, 117, 3, 2, 2, 2, 12,
	120, 3, 2, 2, 2, 14, 148, 3, 2, 2, 2, 16, 153, 3, 2, 2, 2, 18, 212, 3,
	2, 2, 2, 20, 248, 3, 2, 2, 2, 22, 253, 3, 2, 2, 2, 24, 275, 3, 2, 2, 2,
	26, 302, 3, 2, 2, 2, 28, 304, 3, 2, 2, 2, 30, 364, 3, 2, 2, 2, 32, 367,
	3, 2, 2, 2, 34, 371, 3, 2, 2, 2, 36, 399, 3, 2, 2, 2, 38, 479, 3, 2, 2,
	2, 40, 632, 3, 2, 2, 2, 42, 734, 3, 2, 2, 2, 44, 797, 3, 2, 2, 2, 46, 809,
	3, 2, 2, 2, 48, 837, 3, 2, 2, 2, 50, 846, 3, 2, 2, 2, 52, 848, 3, 2, 2,
	2, 54, 852, 3, 2, 2, 2, 56, 866, 3, 2, 2, 2, 58, 894, 3, 2, 2, 2, 60, 896,
	3, 2, 2, 2, 62, 907, 3, 2, 2, 2, 64, 909, 3, 2, 2, 2, 66, 912, 3, 2, 2,
	2, 68, 916, 3, 2, 2, 2, 70, 918, 3, 2, 2, 2, 72, 922, 3, 2, 2, 2, 74, 933,
	3, 2, 2, 2, 76, 937, 3, 2, 2, 2, 78, 939, 3, 2, 2, 2, 80, 82, 5, 4, 3,
	2, 81, 80, 3, 2, 2, 2, 82, 83, 3, 2, 2, 2, 83, 81, 3, 2, 2, 2, 83, 84,
	3, 2, 2, 2, 84, 85, 3, 2, 2, 2, 85, 86, 7, 2, 2, 3, 86, 3, 3, 2, 2, 2,
	87, 89, 7, 3, 2, 2, 88, 90, 7, 36, 2, 2, 89, 88, 3, 2, 2, 2, 89, 90, 3,
	2, 2, 2, 90, 91, 3, 2, 2, 2, 91, 92, 5, 8, 5, 2, 92, 94, 7, 3, 2, 2, 93,
	95, 5, 6, 4, 2, 94, 93, 3, 2, 2, 2, 94, 95, 3, 2, 2, 2, 95, 97, 3, 2, 2,
	2, 96, 98, 7, 4, 2, 2, 97, 96, 3, 2, 2, 2, 97, 98, 3, 2, 2, 2, 98, 99,
	3, 2, 2, 2, 99, 100, 7, 5, 2, 2, 100, 5, 3, 2, 2, 2, 101, 103, 5, 72, 37,
	2, 102, 101, 3, 2, 2, 2, 103, 104, 3, 2, 2, 2, 104, 102, 3, 2, 2, 2, 104,
	105, 3, 2, 2, 2, 105, 7, 3, 2, 2, 2, 106, 111, 5, 10, 6, 2, 107, 108, 7,
	56, 2, 2, 108, 110, 5, 10, 6, 2, 109, 107, 3, 2, 2, 2, 110, 113, 3, 2,
	2, 2, 111, 109, 3, 2, 2, 2, 111, 112, 3, 2, 2, 2, 112, 9, 3, 2, 2, 2, 113,
	111, 3, 2, 2, 2, 114, 116, 5, 12, 7, 2, 115, 114, 3, 2, 2, 2, 116, 119,
	3, 2, 2, 2, 117, 115, 3, 2, 2, 2, 117, 118, 3, 2, 2, 2, 118, 11, 3, 2,
	2, 2, 119, 117, 3, 2, 2, 2, 120, 122, 5, 48, 25, 2, 121, 123, 5, 14, 8,
	2, 122, 121, 3, 2, 2, 2, 122, 123, 3, 2, 2, 2, 123, 13, 3, 2, 2, 2, 124,
	125, 7, 40, 2, 2, 125, 149, 5, 16, 9, 2, 126, 127, 7, 41, 2, 2, 127, 149,
	5, 16, 9, 2, 128, 129, 7, 42, 2, 2, 129, 149, 5, 16, 9, 2, 130, 131, 7,
	43, 2, 2, 131, 132, 5, 60, 31, 2, 132, 133, 7, 44, 2, 2, 133, 134, 5, 16,
	9, 2, 134, 149, 3, 2, 2, 2, 135, 136, 7, 43, 2, 2, 136, 137, 5, 60, 31,
	2, 137, 138, 7, 45, 2, 2, 138, 139, 7, 44, 2, 2, 139, 140, 5, 16, 9, 2,
	140, 149, 3, 2, 2, 2, 141, 142, 7, 43, 2, 2, 142, 143, 5, 60, 31, 2, 143,
	144, 7, 45, 2, 2, 144, 145, 5, 60, 31, 2, 145, 146, 7, 44, 2, 2, 146, 147,
	5, 16, 9, 2, 147, 149, 3, 2, 2, 2, 148, 124, 3, 2, 2, 2, 148, 126, 3, 2,
	2, 2, 148, 128, 3, 2, 2, 2, 148, 130, 3, 2, 2, 2, 148, 135, 3, 2, 2, 2,
	148, 141, 3, 2, 2, 2, 149, 15, 3, 2, 2, 2, 150, 154, 7, 41, 2, 2, 151,
	154, 7, 40, 2, 2, 152, 154, 3, 2, 2, 2, 153, 150, 3, 2, 2, 2, 153, 151,
	3, 2, 2, 2, 153, 152, 3, 2, 2, 2, 154, 17, 3, 2, 2, 2, 155, 156, 7, 34,
	2, 2, 156, 157, 7, 36, 2, 2, 157, 158, 7, 35, 2, 2, 158, 160, 7, 37, 2,
	2, 159, 161, 5, 50, 26, 2, 160, 159, 3, 2, 2, 2, 161, 162, 3, 2, 2, 2,
	162, 160, 3, 2, 2, 2, 162, 163, 3, 2, 2, 2, 163, 164, 3, 2, 2, 2, 164,
	165, 7, 35, 2, 2, 165, 213, 3, 2, 2, 2, 166, 167, 7, 34, 2, 2, 167, 168,
	7, 36, 2, 2, 168, 172, 7, 35, 2, 2, 169, 171, 5, 50, 26, 2, 170, 169, 3,
	2, 2, 2, 171, 174, 3, 2, 2, 2, 172, 170, 3, 2, 2, 2, 172, 173, 3, 2, 2,
	2, 173, 175, 3, 2, 2, 2, 174, 172, 3, 2, 2, 2, 175, 213, 7, 35, 2, 2, 176,
	177, 7, 34, 2, 2, 177, 179, 7, 36, 2, 2, 178, 180, 5, 50, 26, 2, 179, 178,
	3, 2, 2, 2, 180, 181, 3, 2, 2, 2, 181, 179, 3, 2, 2, 2, 181, 182, 3, 2,
	2, 2, 182, 183, 3, 2, 2, 2, 183, 184, 7, 35, 2, 2, 184, 213, 3, 2, 2, 2,
	185, 186, 7, 34, 2, 2, 186, 187, 7, 35, 2, 2, 187, 189, 7, 37, 2, 2, 188,
	190, 5, 50, 26, 2, 189, 188, 3, 2, 2, 2, 190, 191, 3, 2, 2, 2, 191, 189,
	3, 2, 2, 2, 191, 192, 3, 2, 2, 2, 192, 193, 3, 2, 2, 2, 193, 194, 7, 35,
	2, 2, 194, 213, 3, 2, 2, 2, 195, 196, 7, 34, 2, 2, 196, 200, 7, 35, 2,
	2, 197, 199, 5, 50, 26, 2, 198, 197, 3, 2, 2, 2, 199, 202, 3, 2, 2, 2,
	200, 198, 3, 2, 2, 2, 200, 201, 3, 2, 2, 2, 201, 203, 3, 2, 2, 2, 202,
	200, 3, 2, 2, 2, 203, 213, 7, 35, 2, 2, 204, 206, 7, 34, 2, 2, 205, 207,
	5, 50, 26, 2, 206, 205, 3, 2, 2, 2, 207, 208, 3, 2, 2, 2, 208, 206, 3,
	2, 2, 2, 208, 209, 3, 2, 2, 2, 209, 210, 3, 2, 2, 2, 210, 211, 7, 35, 2,
	2, 211, 213, 3, 2, 2, 2, 212, 155, 3, 2, 2, 2, 212, 166, 3, 2, 2, 2, 212,
	176, 3, 2, 2, 2, 212, 185, 3, 2, 2, 2, 212, 195, 3, 2, 2, 2, 212, 204,
	3, 2, 2, 2, 213, 19, 3, 2, 2, 2, 214, 249, 5, 22, 12, 2, 215, 216, 7, 54,
	2, 2, 216, 249, 5, 60, 31, 2, 217, 218, 7, 54, 2, 2, 218, 219, 7, 43, 2,
	2, 219, 220, 5, 60, 31, 2, 220, 221, 7, 44, 2, 2, 221, 249, 3, 2, 2, 2,
	222, 223, 7, 54, 2, 2, 223, 224, 7, 43, 2, 2, 224, 225, 7, 37, 2, 2, 225,
	226, 5, 60, 31, 2, 226, 227, 7, 44, 2, 2, 227, 249, 3, 2, 2, 2, 228, 229,
	7, 55, 2, 2, 229, 230, 7, 59, 2, 2, 230, 231, 5, 70, 36, 2, 231, 232, 7,
	60, 2, 2, 232, 249, 3, 2, 2, 2, 233, 234, 7, 55, 2, 2, 234, 235, 7, 61,
	2, 2, 235, 236, 5, 70, 36, 2, 236, 237, 7, 61, 2, 2, 237, 249, 3, 2, 2,
	2, 238, 239, 7, 54, 2, 2, 239, 240, 7, 43, 2, 2, 240, 241, 5, 70, 36, 2,
	241, 242, 7, 44, 2, 2, 242, 249, 3, 2, 2, 2, 243, 244, 7, 55, 2, 2, 244,
	245, 7, 43, 2, 2, 245, 246, 5, 70, 36, 2, 246, 247, 7, 44, 2, 2, 247, 249,
	3, 2, 2, 2, 248, 214, 3, 2, 2, 2, 248, 215, 3, 2, 2, 2, 248, 217, 3, 2,
	2, 2, 248, 222, 3, 2, 2, 2, 248, 228, 3, 2, 2, 2, 248, 233, 3, 2, 2, 2,
	248, 238, 3, 2, 2, 2, 248, 243, 3, 2, 2, 2, 249, 21, 3, 2, 2, 2, 250, 254,
	5, 62, 32, 2, 251, 252, 7, 15, 2, 2, 252, 254, 5, 68, 35, 2, 253, 250,
	3, 2, 2, 2, 253, 251, 3, 2, 2, 2, 254, 23, 3, 2, 2, 2, 255, 256, 7, 57,
	2, 2, 256, 257, 7, 40, 2, 2, 257, 258, 7, 59, 2, 2, 258, 259, 5, 70, 36,
	2, 259, 260, 7, 60, 2, 2, 260, 261, 5, 8, 5, 2, 261, 262, 7, 58, 2, 2,
	262, 276, 3, 2, 2, 2, 263, 264, 7, 57, 2, 2, 264, 265, 7, 40, 2, 2, 265,
	266, 7, 61, 2, 2, 266, 267, 5, 70, 36, 2, 267, 268, 7, 61, 2, 2, 268, 269,
	5, 8, 5, 2, 269, 270, 7, 58, 2, 2, 270, 276, 3, 2, 2, 2, 271, 272, 7, 57,
	2, 2, 272, 273, 5, 8, 5, 2, 273, 274, 7, 58, 2, 2, 274, 276, 3, 2, 2, 2,
	275, 255, 3, 2, 2, 2, 275, 263, 3, 2, 2, 2, 275, 271, 3, 2, 2, 2, 276,
	25, 3, 2, 2, 2, 277, 278, 7, 57, 2, 2, 278, 279, 7, 40, 2, 2, 279, 280,
	7, 63, 2, 2, 280, 281, 5, 8, 5, 2, 281, 282, 7, 58, 2, 2, 282, 303, 3,
	2, 2, 2, 283, 284, 7, 57, 2, 2, 284, 285, 7, 40, 2, 2, 285, 286, 7, 56,
	2, 2, 286, 287, 5, 8, 5, 2, 287, 288, 7, 58, 2, 2, 288, 303, 3, 2, 2, 2,
	289, 290, 7, 57, 2, 2, 290, 291, 7, 40, 2, 2, 291, 292, 7, 60, 2, 2, 292,
	293, 5, 8, 5, 2, 293, 294, 7, 58, 2, 2, 294, 303, 3, 2, 2, 2, 295, 296,
	7, 57, 2, 2, 296, 297, 7, 40, 2, 2, 297, 298, 5, 32, 17, 2, 298, 299, 7,
	63, 2, 2, 299, 300, 5, 8, 5, 2, 300, 301, 7, 58, 2, 2, 301, 303, 3, 2,
	2, 2, 302, 277, 3, 2, 2, 2, 302, 283, 3, 2, 2, 2, 302, 289, 3, 2, 2, 2,
	302, 295, 3, 2, 2, 2, 303, 27, 3, 2, 2, 2, 304, 305, 7, 57, 2, 2, 305,
	306, 7, 40, 2, 2, 306, 307, 7, 64, 2, 2, 307, 308, 5, 74, 38, 2, 308, 309,
	7, 58, 2, 2, 309, 29, 3, 2, 2, 2, 310, 311, 7, 57, 2, 2, 311, 312, 7, 40,
	2, 2, 312, 313, 5, 32, 17, 2, 313, 314, 7, 37, 2, 2, 314, 315, 5, 32, 17,
	2, 315, 316, 7, 58, 2, 2, 316, 365, 3, 2, 2, 2, 317, 318, 7, 57, 2, 2,
	318, 319, 7, 40, 2, 2, 319, 320, 5, 32, 17, 2, 320, 321, 7, 58, 2, 2, 321,
	365, 3, 2, 2, 2, 322, 323, 7, 57, 2, 2, 323, 324, 7, 40, 2, 2, 324, 325,
	7, 37, 2, 2, 325, 326, 5, 32, 17, 2, 326, 327, 7, 58, 2, 2, 327, 365, 3,
	2, 2, 2, 328, 329, 7, 57, 2, 2, 329, 330, 7, 42, 2, 2, 330, 331, 7, 107,
	2, 2, 331, 332, 7, 108, 2, 2, 332, 333, 7, 62, 2, 2, 333, 334, 7, 112,
	2, 2, 334, 335, 7, 113, 2, 2, 335, 336, 7, 94, 2, 2, 336, 337, 7, 111,
	2, 2, 337, 338, 7, 113, 2, 2, 338, 339, 7, 62, 2, 2, 339, 340, 7, 108,
	2, 2, 340, 341, 7, 109, 2, 2, 341, 342, 7, 113, 2, 2, 342, 365, 7, 58,
	2, 2, 343, 344, 7, 57, 2, 2, 344, 345, 7, 42, 2, 2, 345, 346, 7, 114, 2,
	2, 346, 347, 7, 113, 2, 2, 347, 348, 7, 99, 2, 2, 348, 349, 7, 127, 2,
	2, 349, 365, 7, 58, 2, 2, 350, 351, 7, 57, 2, 2, 351, 352, 7, 42, 2, 2,
	352, 353, 7, 114, 2, 2, 353, 354, 7, 113, 2, 2, 354, 355, 7, 99, 2, 2,
	355, 356, 7, 120, 2, 2, 356, 357, 7, 125, 2, 2, 357, 365, 7, 58, 2, 2,
	358, 359, 7, 57, 2, 2, 359, 360, 7, 42, 2, 2, 360, 361, 7, 114, 2, 2, 361,
	362, 7, 96, 2, 2, 362, 363, 7, 109, 2, 2, 363, 365, 7, 58, 2, 2, 364, 310,
	3, 2, 2, 2, 364, 317, 3, 2, 2, 2, 364, 322, 3, 2, 2, 2, 364, 328, 3, 2,
	2, 2, 364, 343, 3, 2, 2, 2, 364, 350, 3, 2, 2, 2, 364, 358, 3, 2, 2, 2,
	365, 31, 3, 2, 2, 2, 366, 368, 5, 34, 18, 2, 367, 366, 3, 2, 2, 2, 368,
	369, 3, 2, 2, 2, 369, 367, 3, 2, 2, 2, 369, 370, 3, 2, 2, 2, 370, 33, 3,
	2, 2, 2, 371, 372, 9, 2, 2, 2, 372, 35, 3, 2, 2, 2, 373, 374, 7, 57, 2,
	2, 374, 375, 7, 40, 2, 2, 375, 376, 7, 65, 2, 2, 376, 377, 5, 8, 5, 2,
	377, 378, 7, 58, 2, 2, 378, 400, 3, 2, 2, 2, 379, 380, 7, 57, 2, 2, 380,
	381, 7, 40, 2, 2, 381, 382, 7, 66, 2, 2, 382, 383, 5, 8, 5, 2, 383, 384,
	7, 58, 2, 2, 384, 400, 3, 2, 2, 2, 385, 386, 7, 57, 2, 2, 386, 387, 7,
	40, 2, 2, 387, 388, 7, 59, 2, 2, 388, 389, 7, 65, 2, 2, 389, 390, 5, 8,
	5, 2, 390, 391, 7, 58, 2, 2, 391, 400, 3, 2, 2, 2, 392, 393, 7, 57, 2,
	2, 393, 394, 7, 40, 2, 2, 394, 395, 7, 59, 2, 2, 395, 396, 7, 66, 2, 2,
	396, 397, 5, 8, 5, 2, 397, 398, 7, 58, 2, 2, 398, 400, 3, 2, 2, 2, 399,
	373, 3, 2, 2, 2, 399, 379, 3, 2, 2, 2, 399, 385, 3, 2, 2, 2, 399, 392,
	3, 2, 2, 2, 400, 37, 3, 2, 2, 2, 401, 402, 7, 57, 2, 2, 402, 403, 7, 40,
	2, 2, 403, 404, 7, 111, 2, 2, 404, 480, 7, 58, 2, 2, 405, 406, 7, 57, 2,
	2, 406, 407, 7, 40, 2, 2, 407, 408, 5, 60, 31, 2, 408, 409, 7, 58, 2, 2,
	409, 480, 3, 2, 2, 2, 410, 411, 7, 57, 2, 2, 411, 412, 7, 40, 2, 2, 412,
	413, 7, 41, 2, 2, 413, 414, 5, 60, 31, 2, 414, 415, 7, 58, 2, 2, 415, 480,
	3, 2, 2, 2, 416, 417, 7, 57, 2, 2, 417, 418, 7, 40, 2, 2, 418, 419, 7,
	37, 2, 2, 419, 420, 5, 60, 31, 2, 420, 421, 7, 58, 2, 2, 421, 480, 3, 2,
	2, 2, 422, 423, 7, 57, 2, 2, 423, 424, 7, 40, 2, 2, 424, 425, 7, 67, 2,
	2, 425, 426, 5, 70, 36, 2, 426, 427, 7, 58, 2, 2, 427, 480, 3, 2, 2, 2,
	428, 429, 7, 57, 2, 2, 429, 430, 7, 40, 2, 2, 430, 431, 7, 109, 2, 2, 431,
	432, 7, 60, 2, 2, 432, 433, 5, 70, 36, 2, 433, 434, 7, 58, 2, 2, 434, 480,
	3, 2, 2, 2, 435, 436, 7, 54, 2, 2, 436, 437, 7, 59, 2, 2, 437, 438, 5,
	70, 36, 2, 438, 439, 7, 60, 2, 2, 439, 480, 3, 2, 2, 2, 440, 441, 7, 54,
	2, 2, 441, 442, 7, 61, 2, 2, 442, 443, 5, 70, 36, 2, 443, 444, 7, 61, 2,
	2, 444, 480, 3, 2, 2, 2, 445, 446, 7, 54, 2, 2, 446, 447, 7, 59, 2, 2,
	447, 448, 5, 60, 31, 2, 448, 449, 7, 60, 2, 2, 449, 480, 3, 2, 2, 2, 450,
	451, 7, 54, 2, 2, 451, 452, 7, 61, 2, 2, 452, 453, 5, 60, 31, 2, 453, 454,
	7, 61, 2, 2, 454, 480, 3, 2, 2, 2, 455, 456, 7, 54, 2, 2, 456, 457, 7,
	59, 2, 2, 457, 458, 7, 41, 2, 2, 458, 459, 5, 60, 31, 2, 459, 460, 7, 60,
	2, 2, 460, 480, 3, 2, 2, 2, 461, 462, 7, 54, 2, 2, 462, 463, 7, 61, 2,
	2, 463, 464, 7, 41, 2, 2, 464, 465, 5, 60, 31, 2, 465, 466, 7, 61, 2, 2,
	466, 480, 3, 2, 2, 2, 467, 468, 7, 54, 2, 2, 468, 469, 7, 59, 2, 2, 469,
	470, 7, 37, 2, 2, 470, 471, 5, 60, 31, 2, 471, 472, 7, 60, 2, 2, 472, 480,
	3, 2, 2, 2, 473, 474, 7, 54, 2, 2, 474, 475, 7, 61, 2, 2, 475, 476, 7,
	37, 2, 2, 476, 477, 5, 60, 31, 2, 477, 478, 7, 61, 2, 2, 478, 480, 3, 2,
	2, 2, 479, 401, 3, 2, 2, 2, 479, 405, 3, 2, 2, 2, 479, 410, 3, 2, 2, 2,
	479, 416, 3, 2, 2, 2, 479, 422, 3, 2, 2, 2, 479, 428, 3, 2, 2, 2, 479,
	435, 3, 2, 2, 2, 479, 440, 3, 2, 2, 2, 479, 445, 3, 2, 2, 2, 479, 450,
	3, 2, 2, 2, 479, 455, 3, 2, 2, 2, 479, 461, 3, 2, 2, 2, 479, 467, 3, 2,
	2, 2, 479, 473, 3, 2, 2, 2, 480, 39, 3, 2, 2, 2, 481, 482, 7, 57, 2, 2,
	482, 483, 7, 40, 2, 2, 483, 484, 7, 57, 2, 2, 484, 485, 5, 60, 31, 2, 485,
	486, 7, 58, 2, 2, 486, 489, 5, 8, 5, 2, 487, 488, 7, 56, 2, 2, 488, 490,
	5, 8, 5, 2, 489, 487, 3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490, 491, 3, 2,
	2, 2, 491, 492, 7, 58, 2, 2, 492, 633, 3, 2, 2, 2, 493, 494, 7, 57, 2,
	2, 494, 495, 7, 40, 2, 2, 495, 496, 7, 57, 2, 2, 496, 497, 7, 41, 2, 2,
	497, 498, 5, 60, 31, 2, 498, 499, 7, 58, 2, 2, 499, 502, 5, 8, 5, 2, 500,
	501, 7, 56, 2, 2, 501, 503, 5, 8, 5, 2, 502, 500, 3, 2, 2, 2, 502, 503,
	3, 2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 505, 7, 58, 2, 2, 505, 633, 3, 2,
	2, 2, 506, 507, 7, 57, 2, 2, 507, 508, 7, 40, 2, 2, 508, 509, 7, 57, 2,
	2, 509, 510, 7, 37, 2, 2, 510, 511, 5, 60, 31, 2, 511, 512, 7, 58, 2, 2,
	512, 515, 5, 8, 5, 2, 513, 514, 7, 56, 2, 2, 514, 516, 5, 8, 5, 2, 515,
	513, 3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516, 517, 3, 2, 2, 2, 517, 518,
	7, 58, 2, 2, 518, 633, 3, 2, 2, 2, 519, 520, 7, 57, 2, 2, 520, 521, 7,
	40, 2, 2, 521, 522, 7, 57, 2, 2, 522, 523, 7, 59, 2, 2, 523, 524, 5, 70,
	36, 2, 524, 525, 7, 60, 2, 2, 525, 526, 7, 58, 2, 2, 526, 529, 5, 8, 5,
	2, 527, 528, 7, 56, 2, 2, 528, 530, 5, 8, 5, 2, 529, 527, 3, 2, 2, 2, 529,
	530, 3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531, 532, 7, 58, 2, 2, 532, 633,
	3, 2, 2, 2, 533, 534, 7, 57, 2, 2, 534, 535, 7, 40, 2, 2, 535, 536, 7,
	57, 2, 2, 536, 537, 7, 61, 2, 2, 537, 538, 5, 70, 36, 2, 538, 539, 7, 61,
	2, 2, 539, 540, 7, 58, 2, 2, 540, 543, 5, 8, 5, 2, 541, 542, 7, 56, 2,
	2, 542, 544, 5, 8, 5, 2, 543, 541, 3, 2, 2, 2, 543, 544, 3, 2, 2, 2, 544,
	545, 3, 2, 2, 2, 545, 546, 7, 58, 2, 2, 546, 633, 3, 2, 2, 2, 547, 548,
	7, 57, 2, 2, 548, 549, 7, 40, 2, 2, 549, 550, 7, 57, 2, 2, 550, 551, 7,
	111, 2, 2, 551, 552, 5, 60, 31, 2, 552, 553, 7, 58, 2, 2, 553, 556, 5,
	8, 5, 2, 554, 555, 7, 56, 2, 2, 555, 557, 5, 8, 5, 2, 556, 554, 3, 2, 2,
	2, 556, 557, 3, 2, 2, 2, 557, 558, 3, 2, 2, 2, 558, 559, 7, 58, 2, 2, 559,
	633, 3, 2, 2, 2, 560, 561, 7, 57, 2, 2, 561, 562, 7, 40, 2, 2, 562, 563,
	7, 57, 2, 2, 563, 564, 7, 111, 2, 2, 564, 565, 7, 58, 2, 2, 565, 568, 5,
	8, 5, 2, 566, 567, 7, 56, 2, 2, 567, 569, 5, 8, 5, 2, 568, 566, 3, 2, 2,
	2, 568, 569, 3, 2, 2, 2, 569, 570, 3, 2, 2, 2, 570, 571, 7, 58, 2, 2, 571,
	633, 3, 2, 2, 2, 572, 573, 7, 57, 2, 2, 573, 574, 7, 40, 2, 2, 574, 575,
	7, 57, 2, 2, 575, 576, 7, 111, 2, 2, 576, 577, 7, 67, 2, 2, 577, 578, 5,
	70, 36, 2, 578, 579, 7, 58, 2, 2, 579, 582, 5, 8, 5, 2, 580, 581, 7, 56,
	2, 2, 581, 583, 5, 8, 5, 2, 582, 580, 3, 2, 2, 2, 582, 583, 3, 2, 2, 2,
	583, 584, 3, 2, 2, 2, 584, 585, 7, 58, 2, 2, 585, 633, 3, 2, 2, 2, 586,
	587, 7, 57, 2, 2, 587, 588, 7, 40, 2, 2, 588, 589, 7, 57, 2, 2, 589, 590,
	7, 97, 2, 2, 590, 591, 7, 98, 2, 2, 591, 592, 7, 99, 2, 2, 592, 593, 7,
	102, 2, 2, 593, 594, 7, 107, 2, 2, 594, 595, 7, 98, 2, 2, 595, 596, 7,
	58, 2, 2, 596, 599, 5, 8, 5, 2, 597, 598, 7, 56, 2, 2, 598, 600, 5, 8,
	5, 2, 599, 597, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600, 601, 3, 2, 2, 2,
	601, 602, 7, 58, 2, 2, 602, 633, 3, 2, 2, 2, 603, 604, 7, 57, 2, 2, 604,
	605, 7, 40, 2, 2, 605, 606, 7, 57, 2, 2, 606, 607, 7, 68, 2, 2, 607, 608,
	7, 86, 2, 2, 608, 609, 7, 86, 2, 2, 609, 610, 7, 72, 2, 2, 610, 611, 7,
	85, 2, 2, 611, 612, 7, 87, 2, 2, 612, 613, 7, 58, 2, 2, 613, 616, 5, 8,
	5, 2, 614, 615, 7, 56, 2, 2, 615, 617, 5, 8, 5, 2, 616, 614, 3, 2, 2, 2,
	616, 617, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 619, 7, 58, 2, 2, 619,
	633, 3, 2, 2, 2, 620, 621, 7, 57, 2, 2, 621, 622, 7, 40, 2, 2, 622, 623,
	7, 57, 2, 2, 623, 624, 5, 70, 36, 2, 624, 625, 7, 58, 2, 2, 625, 628, 5,
	8, 5, 2, 626, 627, 7, 56, 2, 2, 627, 629, 5, 8, 5, 2, 628, 626, 3, 2, 2,
	2, 628, 629, 3, 2, 2, 2, 629, 630, 3, 2, 2, 2, 630, 631, 7, 58, 2, 2, 631,
	633, 3, 2, 2, 2, 632, 481, 3, 2, 2, 2, 632, 493, 3, 2, 2, 2, 632, 506,
	3, 2, 2, 2, 632, 519, 3, 2, 2, 2, 632, 533, 3, 2, 2, 2, 632, 547, 3, 2,
	2, 2, 632, 560, 3, 2, 2, 2, 632, 572, 3, 2, 2, 2, 632, 586, 3, 2, 2, 2,
	632, 603, 3, 2, 2, 2, 632, 620, 3, 2, 2, 2, 633, 41, 3, 2, 2, 2, 634, 635,
	7, 57, 2, 2, 635, 636, 7, 42, 2, 2, 636, 637, 7, 94, 2, 2, 637, 638, 7,
	96, 2, 2, 638, 639, 7, 96, 2, 2, 639, 640, 7, 98, 2, 2, 640, 641, 7, 109,
	2, 2, 641, 642, 7, 113, 2, 2, 642, 735, 7, 58, 2, 2, 643, 644, 7, 57, 2,
	2, 644, 645, 7, 42, 2, 2, 645, 649, 7, 99, 2, 2, 646, 647, 7, 94, 2, 2,
	647, 648, 7, 102, 2, 2, 648, 650, 7, 105, 2, 2, 649, 646, 3, 2, 2, 2, 649,
	650, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 735, 7, 58, 2, 2, 652, 653,
	7, 57, 2, 2, 653, 658, 7, 42, 2, 2, 654, 655, 7, 106, 2, 2, 655, 656, 7,
	94, 2, 2, 656, 657, 7, 111, 2, 2, 657, 659, 7, 104, 2, 2, 658, 654, 3,
	2, 2, 2, 658, 659, 3, 2, 2, 2, 659, 660, 3, 2, 2, 2, 660, 661, 7, 63, 2,
	2, 661, 662, 7, 107, 2, 2, 662, 663, 7, 94, 2, 2, 663, 664, 7, 106, 2,
	2, 664, 665, 7, 98, 2, 2, 665, 735, 7, 58, 2, 2, 666, 667, 7, 57, 2, 2,
	667, 668, 7, 42, 2, 2, 668, 669, 7, 96, 2, 2, 669, 670, 7, 108, 2, 2, 670,
	671, 7, 106, 2, 2, 671, 672, 7, 106, 2, 2, 672, 673, 7, 102, 2, 2, 673,
	674, 7, 113, 2, 2, 674, 735, 7, 58, 2, 2, 675, 676, 7, 57, 2, 2, 676, 677,
	7, 42, 2, 2, 677, 678, 7, 109, 2, 2, 678, 679, 7, 111, 2, 2, 679, 680,
	7, 114, 2, 2, 680, 681, 7, 107, 2, 2, 681, 682, 7, 98, 2, 2, 682, 735,
	7, 58, 2, 2, 683, 684, 7, 57, 2, 2, 684, 685, 7, 42, 2, 2, 685, 686, 7,
	109, 2, 2, 686, 687, 7, 111, 2, 2, 687, 688, 7, 114, 2, 2, 688, 689, 7,
	107, 2, 2, 689, 690, 7, 98, 2, 2, 690, 691, 7, 63, 2, 2, 691, 692, 7, 107,
	2, 2, 692, 693, 7, 94, 2, 2, 693, 694, 7, 106, 2, 2, 694, 695, 7, 98, 2,
	2, 695, 735, 7, 58, 2, 2, 696, 697, 7, 57, 2, 2, 697, 698, 7, 42, 2, 2,
	698, 699, 7, 112, 2, 2, 699, 700, 7, 104, 2, 2, 700, 701, 7, 102, 2, 2,
	701, 702, 7, 109, 2, 2, 702, 735, 7, 58, 2, 2, 703, 704, 7, 57, 2, 2, 704,
	705, 7, 42, 2, 2, 705, 706, 7, 112, 2, 2, 706, 707, 7, 104, 2, 2, 707,
	708, 7, 102, 2, 2, 708, 709, 7, 109, 2, 2, 709, 710, 7, 63, 2, 2, 710,
	711, 7, 107, 2, 2, 711, 712, 7, 94, 2, 2, 712, 713, 7, 106, 2, 2, 713,
	714, 7, 98, 2, 2, 714, 735, 7, 58, 2, 2, 715, 716, 7, 57, 2, 2, 716, 717,
	7, 42, 2, 2, 717, 718, 7, 113, 2, 2, 718, 719, 7, 101, 2, 2, 719, 720,
	7, 98, 2, 2, 720, 721, 7, 107, 2, 2, 721, 735, 7, 58, 2, 2, 722, 723, 7,
	57, 2, 2, 723, 724, 7, 42, 2, 2, 724, 725, 7, 113, 2, 2, 725, 726, 7, 101,
	2, 2, 726, 727, 7, 98, 2, 2, 727, 728, 7, 107, 2, 2, 728, 729, 7, 63, 2,
	2, 729, 730, 7, 107, 2, 2, 730, 731, 7, 94, 2, 2, 731, 732, 7, 106, 2,
	2, 732, 733, 7, 98, 2, 2, 733, 735, 7, 58, 2, 2, 734, 634, 3, 2, 2, 2,
	734, 643, 3, 2, 2, 2, 734, 652, 3, 2, 2, 2, 734, 666, 3, 2, 2, 2, 734,
	675, 3, 2, 2, 2, 734, 683, 3, 2, 2, 2, 734, 696, 3, 2, 2, 2, 734, 703,
	3, 2, 2, 2, 734, 715, 3, 2, 2, 2, 734, 722, 3, 2, 2, 2, 735, 43, 3, 2,
	2, 2, 736, 737, 7, 57, 2, 2, 737, 738, 7, 42, 2, 2, 738, 739, 7, 96, 2,
	2, 739, 740, 7, 111, 2, 2, 740, 798, 7, 58, 2, 2, 741, 742, 7, 57, 2, 2,
	742, 743, 7, 42, 2, 2, 743, 744, 7, 105, 2, 2, 744, 745, 7, 99, 2, 2, 745,
	798, 7, 58, 2, 2, 746, 747, 7, 57, 2, 2, 747, 748, 7, 42, 2, 2, 748, 749,
	7, 96, 2, 2, 749, 750, 7, 111, 2, 2, 750, 751, 7, 105, 2, 2, 751, 752,
	7, 99, 2, 2, 752, 798, 7, 58, 2, 2, 753, 754, 7, 57, 2, 2, 754, 755, 7,
	42, 2, 2, 755, 756, 7, 94, 2, 2, 756, 757, 7, 107, 2, 2, 757, 758, 7, 118,
	2, 2, 758, 759, 7, 96, 2, 2, 759, 760, 7, 111, 2, 2, 760, 761, 7, 105,
	2, 2, 761, 762, 7, 99, 2, 2, 762, 798, 7, 58, 2, 2, 763, 764, 7, 57, 2,
	2, 764, 765, 7, 42, 2, 2, 765, 766, 7, 94, 2, 2, 766, 767, 7, 107, 2, 2,
	767, 768, 7, 118, 2, 2, 768, 798, 7, 58, 2, 2, 769, 770, 7, 57, 2, 2, 770,
	771, 7, 42, 2, 2, 771, 772, 7, 95, 2, 2, 772, 773, 7, 112, 2, 2, 773, 774,
	7, 111, 2, 2, 774, 775, 7, 62, 2, 2, 775, 776, 7, 94, 2, 2, 776, 777, 7,
	107, 2, 2, 777, 778, 7, 118, 2, 2, 778, 779, 7, 96, 2, 2, 779, 780, 7,
	111, 2, 2, 780, 781, 7, 105, 2, 2, 781, 782, 7, 99, 2, 2, 782, 798, 7,
	58, 2, 2, 783, 784, 7, 57, 2, 2, 784, 785, 7, 42, 2, 2, 785, 786, 7, 95,
	2, 2, 786, 787, 7, 112, 2, 2, 787, 788, 7, 111, 2, 2, 788, 789, 7, 62,
	2, 2, 789, 790, 7, 114, 2, 2, 790, 791, 7, 107, 2, 2, 791, 792, 7, 102,
	2, 2, 792, 793, 7, 96, 2, 2, 793, 794, 7, 108, 2, 2, 794, 795, 7, 97, 2,
	2, 795, 796, 7, 98, 2, 2, 796, 798, 7, 58, 2, 2, 797, 736, 3, 2, 2, 2,
	797, 741, 3, 2, 2, 2, 797, 746, 3, 2, 2, 2, 797, 753, 3, 2, 2, 2, 797,
	763, 3, 2, 2, 2, 797, 769, 3, 2, 2, 2, 797, 783, 3, 2, 2, 2, 798, 45, 3,
	2, 2, 2, 799, 800, 7, 57, 2, 2, 800, 801, 7, 40, 2, 2, 801, 802, 7, 96,
	2, 2, 802, 810, 7, 58, 2, 2, 803, 804, 7, 57, 2, 2, 804, 805, 7, 40, 2,
	2, 805, 806, 7, 96, 2, 2, 806, 807, 5, 60, 31, 2, 807, 808, 7, 58, 2, 2,
	808, 810, 3, 2, 2, 2, 809, 799, 3, 2, 2, 2, 809, 803, 3, 2, 2, 2, 810,
	47, 3, 2, 2, 2, 811, 838, 5, 38, 20, 2, 812, 838, 5, 52, 27, 2, 813, 838,
	5, 54, 28, 2, 814, 838, 5, 18, 10, 2, 815, 838, 5, 24, 13, 2, 816, 838,
	5, 26, 14, 2, 817, 838, 5, 28, 15, 2, 818, 838, 5, 30, 16, 2, 819, 838,
	5, 36, 19, 2, 820, 838, 5, 20, 11, 2, 821, 838, 5, 40, 21, 2, 822, 838,
	5, 42, 22, 2, 823, 838, 5, 44, 23, 2, 824, 838, 5, 46, 24, 2, 825, 838,
	7, 17, 2, 2, 826, 838, 7, 36, 2, 2, 827, 838, 7, 48, 2, 2, 828, 838, 7,
	46, 2, 2, 829, 838, 7, 47, 2, 2, 830, 838, 7, 49, 2, 2, 831, 838, 7, 50,
	2, 2, 832, 838, 7, 51, 2, 2, 833, 838, 7, 52, 2, 2, 834, 838, 7, 53, 2,
	2, 835, 838, 7, 18, 2, 2, 836, 838, 7, 33, 2, 2, 837, 811, 3, 2, 2, 2,
	837, 812, 3, 2, 2, 2, 837, 813, 3, 2, 2, 2, 837, 814, 3, 2, 2, 2, 837,
	815, 3, 2, 2, 2, 837, 816, 3, 2, 2, 2, 837, 817, 3, 2, 2, 2, 837, 818,
	3, 2, 2, 2, 837, 819, 3, 2, 2, 2, 837, 820, 3, 2, 2, 2, 837, 821, 3, 2,
	2, 2, 837, 822, 3, 2, 2, 2, 837, 823, 3, 2, 2, 2, 837, 824, 3, 2, 2, 2,
	837, 825, 3, 2, 2, 2, 837, 826, 3, 2, 2, 2, 837, 827, 3, 2, 2, 2, 837,
	828, 3, 2, 2, 2, 837, 829, 3, 2, 2, 2, 837, 830, 3, 2, 2, 2, 837, 831,
	3, 2, 2, 2, 837, 832, 3, 2, 2, 2, 837, 833, 3, 2, 2, 2, 837, 834, 3, 2,
	2, 2, 837, 835, 3, 2, 2, 2, 837, 836, 3, 2, 2, 2, 838, 49, 3, 2, 2, 2,
	839, 840, 5, 56, 29, 2, 840, 841, 7, 37, 2, 2, 841, 842, 5, 56, 29, 2,
	842, 847, 3, 2, 2, 2, 843, 847, 5, 52, 27, 2, 844, 847, 5, 56, 29, 2, 845,
	847, 5, 22, 12, 2, 846, 839, 3, 2, 2, 2, 846, 843, 3, 2, 2, 2, 846, 844,
	3, 2, 2, 2, 846, 845, 3, 2, 2, 2, 847, 51, 3, 2, 2, 2, 848, 849, 9, 3,
	2, 2, 849, 53, 3, 2, 2, 2, 850, 853, 5, 58, 30, 2, 851, 853, 7, 35, 2,
	2, 852, 850, 3, 2, 2, 2, 852, 851, 3, 2, 2, 2, 853, 55, 3, 2, 2, 2, 854,
	867, 5, 58, 30, 2, 855, 867, 7, 17, 2, 2, 856, 867, 7, 34, 2, 2, 857, 867,
	7, 36, 2, 2, 858, 867, 7, 40, 2, 2, 859, 867, 7, 41, 2, 2, 860, 867, 7,
	42, 2, 2, 861, 867, 7, 46, 2, 2, 862, 867, 7, 49, 2, 2, 863, 867, 7, 56,
	2, 2, 864, 867, 7, 57, 2, 2, 865, 867, 7, 58, 2, 2, 866, 854, 3, 2, 2,
	2, 866, 855, 3, 2, 2, 2, 866, 856, 3, 2, 2, 2, 866, 857, 3, 2, 2, 2, 866,
	858, 3, 2, 2, 2, 866, 859, 3, 2, 2, 2, 866, 860, 3, 2, 2, 2, 866, 861,
	3, 2, 2, 2, 866, 862, 3, 2, 2, 2, 866, 863, 3, 2, 2, 2, 866, 864, 3, 2,
	2, 2, 866, 865, 3, 2, 2, 2, 867, 57, 3, 2, 2, 2, 868, 895, 5, 62, 32, 2,
	869, 895, 5, 78, 40, 2, 870, 895, 5, 68, 35, 2, 871, 895, 7, 8, 2, 2, 872,
	895, 7, 10, 2, 2, 873, 895, 7, 11, 2, 2, 874, 895, 7, 12, 2, 2, 875, 895,
	7, 13, 2, 2, 876, 895, 7, 14, 2, 2, 877, 895, 7, 16, 2, 2, 878, 895, 7,
	6, 2, 2, 879, 895, 7, 7, 2, 2, 880, 895, 7, 43, 2, 2, 881, 895, 7, 44,
	2, 2, 882, 895, 7, 45, 2, 2, 883, 895, 7, 37, 2, 2, 884, 895, 7, 59, 2,
	2, 885, 895, 7, 60, 2, 2, 886, 895, 7, 61, 2, 2, 887, 895, 7, 62, 2, 2,
	888, 895, 7, 63, 2, 2, 889, 895, 7, 64, 2, 2, 890, 895, 7, 65, 2, 2, 891,
	895, 7, 66, 2, 2, 892, 895, 7, 67, 2, 2, 893, 895, 7, 130, 2, 2, 894, 868,
	3, 2, 2, 2, 894, 869, 3, 2, 2, 2, 894, 870, 3, 2, 2, 2, 894, 871, 3, 2,
	2, 2, 894, 872, 3, 2, 2, 2, 894, 873, 3, 2, 2, 2, 894, 874, 3, 2, 2, 2,
	894, 875, 3, 2, 2, 2, 894, 876, 3, 2, 2, 2, 894, 877, 3, 2, 2, 2, 894,
	878, 3, 2, 2, 2, 894, 879, 3, 2, 2, 2, 894, 880, 3, 2, 2, 2, 894, 881,
	3, 2, 2, 2, 894, 882, 3, 2, 2, 2, 894, 883, 3, 2, 2, 2, 894, 884, 3, 2,
	2, 2, 894, 885, 3, 2, 2, 2, 894, 886, 3, 2, 2, 2, 894, 887, 3, 2, 2, 2,
	894, 888, 3, 2, 2, 2, 894, 889, 3, 2, 2, 2, 894, 890, 3, 2, 2, 2, 894,
	891, 3, 2, 2, 2, 894, 892, 3, 2, 2, 2, 894, 893, 3, 2, 2, 2, 895, 59, 3,
	2, 2, 2, 896, 897, 5, 66, 34, 2, 897, 61, 3, 2, 2, 2, 898, 899, 7, 15,
	2, 2, 899, 900, 9, 4, 2, 2, 900, 901, 5, 64, 33, 2, 901, 902, 5, 64, 33,
	2, 902, 908, 3, 2, 2, 2, 903, 904, 7, 15, 2, 2, 904, 905, 5, 64, 33, 2,
	905, 906, 5, 64, 33, 2, 906, 908, 3, 2, 2, 2, 907, 898, 3, 2, 2, 2, 907,
	903, 3, 2, 2, 2, 908, 63, 3, 2, 2, 2, 909, 910, 9, 5, 2, 2, 910, 65, 3,
	2, 2, 2, 911, 913, 5, 68, 35, 2, 912, 911, 3, 2, 2, 2, 913, 914, 3, 2,
	2, 2, 914, 912, 3, 2, 2, 2, 914, 915, 3, 2, 2, 2, 915, 67, 3, 2, 2, 2,
	916, 917, 9, 6, 2, 2, 917, 69, 3, 2, 2, 2, 918, 919, 5, 72, 37, 2, 919,
	71, 3, 2, 2, 2, 920, 923, 5, 78, 40, 2, 921, 923, 7, 62, 2, 2, 922, 920,
	3, 2, 2, 2, 922, 921, 3, 2, 2, 2, 923, 929, 3, 2, 2, 2, 924, 928, 5, 78,
	40, 2, 925, 928, 7, 62, 2, 2, 926, 928, 5, 68, 35, 2, 927, 924, 3, 2, 2,
	2, 927, 925, 3, 2, 2, 2, 927, 926, 3, 2, 2, 2, 928, 931, 3, 2, 2, 2, 929,
	927, 3, 2, 2, 2, 929, 930, 3, 2, 2, 2, 930, 73, 3, 2, 2, 2, 931, 929, 3,
	2, 2, 2, 932, 934, 5, 76, 39, 2, 933, 932, 3, 2, 2, 2, 934, 935, 3, 2,
	2, 2, 935, 933, 3, 2, 2, 2, 935, 936, 3, 2, 2, 2, 936, 75, 3, 2, 2, 2,
	937, 938, 10, 7, 2, 2, 938, 77, 3, 2, 2, 2, 939, 940, 9, 8, 2, 2, 940,
	79, 3, 2, 2, 2, 55, 83, 89, 94, 97, 104, 111, 117, 122, 148, 153, 162,
	172, 181, 191, 200, 208, 212, 248, 253, 275, 302, 364, 369, 399, 479, 489,
	502, 515, 529, 543, 556, 568, 582, 599, 616, 628, 632, 649, 658, 734, 797,
	809, 837, 846, 852, 866, 894, 907, 914, 922, 927, 929, 935,
}
var literalNames = []string{
	"", "'/'", "'\r'", "'\n'", "", "", "'\\a'", "'\\c'", "'\\e'", "'\\f'",
	"'\\n'", "'\\r'", "'\\t'", "'\\'", "", "'.'", "'\\C'", "'\\d'", "'\\D'",
	"'\\h'", "'\\H'", "'\\N'", "", "", "'\\R'", "'\\s'", "'\\S'", "'\\v'",
	"'\\V'", "'\\w'", "'\\W'", "'\\X'", "'['", "']'", "'^'", "'-'", "", "",
	"'?'", "'+'", "'*'", "'{'", "'}'", "','", "'\\b'", "'\\B'", "'\\A'", "'$'",
	"'\\Z'", "'\\z'", "'\\G'", "'\\K'", "'\\g'", "'\\k'", "'|'", "'('", "')'",
	"'<'", "'>'", "'''", "'_'", "':'", "'#'", "'='", "'!'", "'&'", "'a'", "'b'",
	"'c'", "'d'", "'e'", "'f'", "'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'",
	"'n'", "'o'", "'p'", "'q'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'",
	"'y'", "'z'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'G'", "'H'", "'I'",
	"'J'", "'K'", "'L'", "'M'", "'N'", "'O'", "'P'", "'Q'", "'R'", "'S'", "'T'",
	"'U'", "'V'", "'W'", "'X'", "'Y'", "'Z'", "'1'", "'2'", "'3'", "'4'", "'5'",
	"'6'", "'7'", "'8'", "'9'", "'0'",
}
var symbolicNames = []string{
	"", "", "", "", "Quoted", "BlockQuoted", "BellChar", "ControlChar", "EscapeChar",
	"FormFeed", "NewLine", "CarriageReturn", "Tab", "Backslash", "HexChar",
	"Dot", "OneDataUnit", "DecimalDigit", "NotDecimalDigit", "HorizontalWhiteSpace",
	"NotHorizontalWhiteSpace", "NotNewLine", "CharWithProperty", "CharWithoutProperty",
	"NewLineSequence", "WhiteSpace", "NotWhiteSpace", "VerticalWhiteSpace",
	"NotVerticalWhiteSpace", "WordChar", "NotWordChar", "ExtendedUnicodeChar",
	"CharacterClassStart", "CharacterClassEnd", "Caret", "Hyphen", "POSIXNamedSet",
	"POSIXNegatedNamedSet", "QuestionMark", "Plus", "Star", "OpenBrace", "CloseBrace",
	"Comma", "WordBoundary", "NonWordBoundary", "StartOfSubject", "EndOfSubjectOrLine",
	"EndOfSubjectOrLineEndOfSubject", "EndOfSubject", "PreviousMatchInSubject",
	"ResetStartMatch", "SubroutineOrNamedReferenceStartG", "NamedReferenceStartK",
	"Pipe", "OpenParen", "CloseParen", "LessThan", "GreaterThan", "SingleQuote",
	"Underscore", "Colon", "Hash", "Equals", "Exclamation", "Ampersand", "ALC",
	"BLC", "CLC", "DLC", "ELC", "FLC", "GLC", "HLC", "ILC", "JLC", "KLC", "LLC",
	"MLC", "NLC", "OLC", "PLC", "QLC", "RLC", "SLC", "TLC", "ULC", "VLC", "WLC",
	"XLC", "YLC", "ZLC", "AUC", "BUC", "CUC", "DUC", "EUC", "FUC", "GUC", "HUC",
	"IUC", "JUC", "KUC", "LUC", "MUC", "NUC", "OUC", "PUC", "QUC", "RUC", "SUC",
	"TUC", "UUC", "VUC", "WUC", "XUC", "YUC", "ZUC", "D1", "D2", "D3", "D4",
	"D5", "D6", "D7", "D8", "D9", "D0", "OtherChar",
}

var ruleNames = []string{
	"parse", "singleRule", "directives", "alternation", "expr", "element",
	"quantifier", "quantifier_type", "character_class", "backreference", "backreference_or_octal",
	"capture", "non_capture", "comment", "option", "option_flags", "option_flag",
	"look_around", "subroutine_reference", "conditional", "backtrack_control",
	"newline_convention", "callout", "atom", "cc_atom", "shared_atom", "literal",
	"cc_literal", "shared_literal", "number", "octal_char", "octal_digit",
	"digits", "digit", "name", "alpha_nums", "non_close_parens", "non_close_paren",
	"letter",
}

type PCREParser struct {
	*antlr.BaseParser
}

// NewPCREParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *PCREParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewPCREParser(input antlr.TokenStream) *PCREParser {
	this := new(PCREParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "PCRE.g4"

	return this
}

// PCREParser tokens.
const (
	PCREParserEOF                              = antlr.TokenEOF
	PCREParserT__0                             = 1
	PCREParserT__1                             = 2
	PCREParserT__2                             = 3
	PCREParserQuoted                           = 4
	PCREParserBlockQuoted                      = 5
	PCREParserBellChar                         = 6
	PCREParserControlChar                      = 7
	PCREParserEscapeChar                       = 8
	PCREParserFormFeed                         = 9
	PCREParserNewLine                          = 10
	PCREParserCarriageReturn                   = 11
	PCREParserTab                              = 12
	PCREParserBackslash                        = 13
	PCREParserHexChar                          = 14
	PCREParserDot                              = 15
	PCREParserOneDataUnit                      = 16
	PCREParserDecimalDigit                     = 17
	PCREParserNotDecimalDigit                  = 18
	PCREParserHorizontalWhiteSpace             = 19
	PCREParserNotHorizontalWhiteSpace          = 20
	PCREParserNotNewLine                       = 21
	PCREParserCharWithProperty                 = 22
	PCREParserCharWithoutProperty              = 23
	PCREParserNewLineSequence                  = 24
	PCREParserWhiteSpace                       = 25
	PCREParserNotWhiteSpace                    = 26
	PCREParserVerticalWhiteSpace               = 27
	PCREParserNotVerticalWhiteSpace            = 28
	PCREParserWordChar                         = 29
	PCREParserNotWordChar                      = 30
	PCREParserExtendedUnicodeChar              = 31
	PCREParserCharacterClassStart              = 32
	PCREParserCharacterClassEnd                = 33
	PCREParserCaret                            = 34
	PCREParserHyphen                           = 35
	PCREParserPOSIXNamedSet                    = 36
	PCREParserPOSIXNegatedNamedSet             = 37
	PCREParserQuestionMark                     = 38
	PCREParserPlus                             = 39
	PCREParserStar                             = 40
	PCREParserOpenBrace                        = 41
	PCREParserCloseBrace                       = 42
	PCREParserComma                            = 43
	PCREParserWordBoundary                     = 44
	PCREParserNonWordBoundary                  = 45
	PCREParserStartOfSubject                   = 46
	PCREParserEndOfSubjectOrLine               = 47
	PCREParserEndOfSubjectOrLineEndOfSubject   = 48
	PCREParserEndOfSubject                     = 49
	PCREParserPreviousMatchInSubject           = 50
	PCREParserResetStartMatch                  = 51
	PCREParserSubroutineOrNamedReferenceStartG = 52
	PCREParserNamedReferenceStartK             = 53
	PCREParserPipe                             = 54
	PCREParserOpenParen                        = 55
	PCREParserCloseParen                       = 56
	PCREParserLessThan                         = 57
	PCREParserGreaterThan                      = 58
	PCREParserSingleQuote                      = 59
	PCREParserUnderscore                       = 60
	PCREParserColon                            = 61
	PCREParserHash                             = 62
	PCREParserEquals                           = 63
	PCREParserExclamation                      = 64
	PCREParserAmpersand                        = 65
	PCREParserALC                              = 66
	PCREParserBLC                              = 67
	PCREParserCLC                              = 68
	PCREParserDLC                              = 69
	PCREParserELC                              = 70
	PCREParserFLC                              = 71
	PCREParserGLC                              = 72
	PCREParserHLC                              = 73
	PCREParserILC                              = 74
	PCREParserJLC                              = 75
	PCREParserKLC                              = 76
	PCREParserLLC                              = 77
	PCREParserMLC                              = 78
	PCREParserNLC                              = 79
	PCREParserOLC                              = 80
	PCREParserPLC                              = 81
	PCREParserQLC                              = 82
	PCREParserRLC                              = 83
	PCREParserSLC                              = 84
	PCREParserTLC                              = 85
	PCREParserULC                              = 86
	PCREParserVLC                              = 87
	PCREParserWLC                              = 88
	PCREParserXLC                              = 89
	PCREParserYLC                              = 90
	PCREParserZLC                              = 91
	PCREParserAUC                              = 92
	PCREParserBUC                              = 93
	PCREParserCUC                              = 94
	PCREParserDUC                              = 95
	PCREParserEUC                              = 96
	PCREParserFUC                              = 97
	PCREParserGUC                              = 98
	PCREParserHUC                              = 99
	PCREParserIUC                              = 100
	PCREParserJUC                              = 101
	PCREParserKUC                              = 102
	PCREParserLUC                              = 103
	PCREParserMUC                              = 104
	PCREParserNUC                              = 105
	PCREParserOUC                              = 106
	PCREParserPUC                              = 107
	PCREParserQUC                              = 108
	PCREParserRUC                              = 109
	PCREParserSUC                              = 110
	PCREParserTUC                              = 111
	PCREParserUUC                              = 112
	PCREParserVUC                              = 113
	PCREParserWUC                              = 114
	PCREParserXUC                              = 115
	PCREParserYUC                              = 116
	PCREParserZUC                              = 117
	PCREParserD1                               = 118
	PCREParserD2                               = 119
	PCREParserD3                               = 120
	PCREParserD4                               = 121
	PCREParserD5                               = 122
	PCREParserD6                               = 123
	PCREParserD7                               = 124
	PCREParserD8                               = 125
	PCREParserD9                               = 126
	PCREParserD0                               = 127
	PCREParserOtherChar                        = 128
)

// PCREParser rules.
const (
	PCREParserRULE_parse                  = 0
	PCREParserRULE_singleRule             = 1
	PCREParserRULE_directives             = 2
	PCREParserRULE_alternation            = 3
	PCREParserRULE_expr                   = 4
	PCREParserRULE_element                = 5
	PCREParserRULE_quantifier             = 6
	PCREParserRULE_quantifier_type        = 7
	PCREParserRULE_character_class        = 8
	PCREParserRULE_backreference          = 9
	PCREParserRULE_backreference_or_octal = 10
	PCREParserRULE_capture                = 11
	PCREParserRULE_non_capture            = 12
	PCREParserRULE_comment                = 13
	PCREParserRULE_option                 = 14
	PCREParserRULE_option_flags           = 15
	PCREParserRULE_option_flag            = 16
	PCREParserRULE_look_around            = 17
	PCREParserRULE_subroutine_reference   = 18
	PCREParserRULE_conditional            = 19
	PCREParserRULE_backtrack_control      = 20
	PCREParserRULE_newline_convention     = 21
	PCREParserRULE_callout                = 22
	PCREParserRULE_atom                   = 23
	PCREParserRULE_cc_atom                = 24
	PCREParserRULE_shared_atom            = 25
	PCREParserRULE_literal                = 26
	PCREParserRULE_cc_literal             = 27
	PCREParserRULE_shared_literal         = 28
	PCREParserRULE_number                 = 29
	PCREParserRULE_octal_char             = 30
	PCREParserRULE_octal_digit            = 31
	PCREParserRULE_digits                 = 32
	PCREParserRULE_digit                  = 33
	PCREParserRULE_name                   = 34
	PCREParserRULE_alpha_nums             = 35
	PCREParserRULE_non_close_parens       = 36
	PCREParserRULE_non_close_paren        = 37
	PCREParserRULE_letter                 = 38
)

// IParseContext is an interface to support dynamic dispatch.
type IParseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParseContext differentiates from other interfaces.
	IsParseContext()
}

type ParseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseContext() *ParseContext {
	var p = new(ParseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_parse
	return p
}

func (*ParseContext) IsParseContext() {}

func NewParseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseContext {
	var p = new(ParseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_parse

	return p
}

func (s *ParseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseContext) EOF() antlr.TerminalNode {
	return s.GetToken(PCREParserEOF, 0)
}

func (s *ParseContext) AllSingleRule() []ISingleRuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleRuleContext)(nil)).Elem())
	var tst = make([]ISingleRuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleRuleContext)
		}
	}

	return tst
}

func (s *ParseContext) SingleRule(i int) ISingleRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleRuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleRuleContext)
}

func (s *ParseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterParse(s)
	}
}

func (s *ParseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitParse(s)
	}
}

func (s *ParseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitParse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Parse() (localctx IParseContext) {
	localctx = NewParseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PCREParserRULE_parse)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(79)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PCREParserT__0 {
		{
			p.SetState(78)
			p.SingleRule()
		}

		p.SetState(81)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(83)
		p.Match(PCREParserEOF)
	}

	return localctx
}

// ISingleRuleContext is an interface to support dynamic dispatch.
type ISingleRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleRuleContext differentiates from other interfaces.
	IsSingleRuleContext()
}

type SingleRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleRuleContext() *SingleRuleContext {
	var p = new(SingleRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_singleRule
	return p
}

func (*SingleRuleContext) IsSingleRuleContext() {}

func NewSingleRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleRuleContext {
	var p = new(SingleRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_singleRule

	return p
}

func (s *SingleRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleRuleContext) Alternation() IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *SingleRuleContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *SingleRuleContext) Directives() IDirectivesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectivesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirectivesContext)
}

func (s *SingleRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterSingleRule(s)
	}
}

func (s *SingleRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitSingleRule(s)
	}
}

func (s *SingleRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitSingleRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) SingleRule() (localctx ISingleRuleContext) {
	localctx = NewSingleRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PCREParserRULE_singleRule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(85)
		p.Match(PCREParserT__0)
	}
	p.SetState(87)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(86)
			p.Match(PCREParserCaret)
		}

	}
	{
		p.SetState(89)
		p.Alternation()
	}
	{
		p.SetState(90)
		p.Match(PCREParserT__0)
	}
	p.SetState(92)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(PCREParserUnderscore-60))|(1<<(PCREParserALC-60))|(1<<(PCREParserBLC-60))|(1<<(PCREParserCLC-60))|(1<<(PCREParserDLC-60))|(1<<(PCREParserELC-60))|(1<<(PCREParserFLC-60))|(1<<(PCREParserGLC-60))|(1<<(PCREParserHLC-60))|(1<<(PCREParserILC-60))|(1<<(PCREParserJLC-60))|(1<<(PCREParserKLC-60))|(1<<(PCREParserLLC-60))|(1<<(PCREParserMLC-60))|(1<<(PCREParserNLC-60))|(1<<(PCREParserOLC-60))|(1<<(PCREParserPLC-60))|(1<<(PCREParserQLC-60))|(1<<(PCREParserRLC-60))|(1<<(PCREParserSLC-60))|(1<<(PCREParserTLC-60))|(1<<(PCREParserULC-60))|(1<<(PCREParserVLC-60))|(1<<(PCREParserWLC-60))|(1<<(PCREParserXLC-60))|(1<<(PCREParserYLC-60))|(1<<(PCREParserZLC-60)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(PCREParserAUC-92))|(1<<(PCREParserBUC-92))|(1<<(PCREParserCUC-92))|(1<<(PCREParserDUC-92))|(1<<(PCREParserEUC-92))|(1<<(PCREParserFUC-92))|(1<<(PCREParserGUC-92))|(1<<(PCREParserHUC-92))|(1<<(PCREParserIUC-92))|(1<<(PCREParserJUC-92))|(1<<(PCREParserKUC-92))|(1<<(PCREParserLUC-92))|(1<<(PCREParserMUC-92))|(1<<(PCREParserNUC-92))|(1<<(PCREParserOUC-92))|(1<<(PCREParserPUC-92))|(1<<(PCREParserQUC-92))|(1<<(PCREParserRUC-92))|(1<<(PCREParserSUC-92))|(1<<(PCREParserTUC-92))|(1<<(PCREParserUUC-92))|(1<<(PCREParserVUC-92))|(1<<(PCREParserWUC-92))|(1<<(PCREParserXUC-92))|(1<<(PCREParserYUC-92))|(1<<(PCREParserZUC-92)))) != 0) {
		{
			p.SetState(91)
			p.Directives()
		}

	}
	p.SetState(95)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PCREParserT__1 {
		{
			p.SetState(94)
			p.Match(PCREParserT__1)
		}

	}
	{
		p.SetState(97)
		p.Match(PCREParserT__2)
	}

	return localctx
}

// IDirectivesContext is an interface to support dynamic dispatch.
type IDirectivesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectivesContext differentiates from other interfaces.
	IsDirectivesContext()
}

type DirectivesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectivesContext() *DirectivesContext {
	var p = new(DirectivesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_directives
	return p
}

func (*DirectivesContext) IsDirectivesContext() {}

func NewDirectivesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectivesContext {
	var p = new(DirectivesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_directives

	return p
}

func (s *DirectivesContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectivesContext) AllAlpha_nums() []IAlpha_numsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlpha_numsContext)(nil)).Elem())
	var tst = make([]IAlpha_numsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlpha_numsContext)
		}
	}

	return tst
}

func (s *DirectivesContext) Alpha_nums(i int) IAlpha_numsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlpha_numsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlpha_numsContext)
}

func (s *DirectivesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectivesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectivesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterDirectives(s)
	}
}

func (s *DirectivesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitDirectives(s)
	}
}

func (s *DirectivesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitDirectives(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Directives() (localctx IDirectivesContext) {
	localctx = NewDirectivesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PCREParserRULE_directives)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(100)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(PCREParserUnderscore-60))|(1<<(PCREParserALC-60))|(1<<(PCREParserBLC-60))|(1<<(PCREParserCLC-60))|(1<<(PCREParserDLC-60))|(1<<(PCREParserELC-60))|(1<<(PCREParserFLC-60))|(1<<(PCREParserGLC-60))|(1<<(PCREParserHLC-60))|(1<<(PCREParserILC-60))|(1<<(PCREParserJLC-60))|(1<<(PCREParserKLC-60))|(1<<(PCREParserLLC-60))|(1<<(PCREParserMLC-60))|(1<<(PCREParserNLC-60))|(1<<(PCREParserOLC-60))|(1<<(PCREParserPLC-60))|(1<<(PCREParserQLC-60))|(1<<(PCREParserRLC-60))|(1<<(PCREParserSLC-60))|(1<<(PCREParserTLC-60))|(1<<(PCREParserULC-60))|(1<<(PCREParserVLC-60))|(1<<(PCREParserWLC-60))|(1<<(PCREParserXLC-60))|(1<<(PCREParserYLC-60))|(1<<(PCREParserZLC-60)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(PCREParserAUC-92))|(1<<(PCREParserBUC-92))|(1<<(PCREParserCUC-92))|(1<<(PCREParserDUC-92))|(1<<(PCREParserEUC-92))|(1<<(PCREParserFUC-92))|(1<<(PCREParserGUC-92))|(1<<(PCREParserHUC-92))|(1<<(PCREParserIUC-92))|(1<<(PCREParserJUC-92))|(1<<(PCREParserKUC-92))|(1<<(PCREParserLUC-92))|(1<<(PCREParserMUC-92))|(1<<(PCREParserNUC-92))|(1<<(PCREParserOUC-92))|(1<<(PCREParserPUC-92))|(1<<(PCREParserQUC-92))|(1<<(PCREParserRUC-92))|(1<<(PCREParserSUC-92))|(1<<(PCREParserTUC-92))|(1<<(PCREParserUUC-92))|(1<<(PCREParserVUC-92))|(1<<(PCREParserWUC-92))|(1<<(PCREParserXUC-92))|(1<<(PCREParserYUC-92))|(1<<(PCREParserZUC-92)))) != 0) {
		{
			p.SetState(99)
			p.Alpha_nums()
		}

		p.SetState(102)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlternationContext is an interface to support dynamic dispatch.
type IAlternationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternationContext differentiates from other interfaces.
	IsAlternationContext()
}

type AlternationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternationContext() *AlternationContext {
	var p = new(AlternationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_alternation
	return p
}

func (*AlternationContext) IsAlternationContext() {}

func NewAlternationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternationContext {
	var p = new(AlternationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_alternation

	return p
}

func (s *AlternationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternationContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *AlternationContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AlternationContext) AllPipe() []antlr.TerminalNode {
	return s.GetTokens(PCREParserPipe)
}

func (s *AlternationContext) Pipe(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, i)
}

func (s *AlternationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAlternation(s)
	}
}

func (s *AlternationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAlternation(s)
	}
}

func (s *AlternationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAlternation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Alternation() (localctx IAlternationContext) {
	localctx = NewAlternationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PCREParserRULE_alternation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(104)
		p.Expr()
	}
	p.SetState(109)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(105)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(106)
				p.Expr()
			}

		}
		p.SetState(111)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllElement() []IElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElementContext)(nil)).Elem())
	var tst = make([]IElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElementContext)
		}
	}

	return tst
}

func (s *ExprContext) Element(i int) IElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PCREParserRULE_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(115)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-4)&-(0x1f+1)) == 0 && ((1<<uint((_la-4)))&((1<<(PCREParserQuoted-4))|(1<<(PCREParserBlockQuoted-4))|(1<<(PCREParserBellChar-4))|(1<<(PCREParserControlChar-4))|(1<<(PCREParserEscapeChar-4))|(1<<(PCREParserFormFeed-4))|(1<<(PCREParserNewLine-4))|(1<<(PCREParserCarriageReturn-4))|(1<<(PCREParserTab-4))|(1<<(PCREParserBackslash-4))|(1<<(PCREParserHexChar-4))|(1<<(PCREParserDot-4))|(1<<(PCREParserOneDataUnit-4))|(1<<(PCREParserDecimalDigit-4))|(1<<(PCREParserNotDecimalDigit-4))|(1<<(PCREParserHorizontalWhiteSpace-4))|(1<<(PCREParserNotHorizontalWhiteSpace-4))|(1<<(PCREParserNotNewLine-4))|(1<<(PCREParserCharWithProperty-4))|(1<<(PCREParserCharWithoutProperty-4))|(1<<(PCREParserNewLineSequence-4))|(1<<(PCREParserWhiteSpace-4))|(1<<(PCREParserNotWhiteSpace-4))|(1<<(PCREParserVerticalWhiteSpace-4))|(1<<(PCREParserNotVerticalWhiteSpace-4))|(1<<(PCREParserWordChar-4))|(1<<(PCREParserNotWordChar-4))|(1<<(PCREParserExtendedUnicodeChar-4))|(1<<(PCREParserCharacterClassStart-4))|(1<<(PCREParserCharacterClassEnd-4))|(1<<(PCREParserCaret-4))|(1<<(PCREParserHyphen-4)))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PCREParserPOSIXNamedSet-36))|(1<<(PCREParserPOSIXNegatedNamedSet-36))|(1<<(PCREParserOpenBrace-36))|(1<<(PCREParserCloseBrace-36))|(1<<(PCREParserComma-36))|(1<<(PCREParserWordBoundary-36))|(1<<(PCREParserNonWordBoundary-36))|(1<<(PCREParserStartOfSubject-36))|(1<<(PCREParserEndOfSubjectOrLine-36))|(1<<(PCREParserEndOfSubjectOrLineEndOfSubject-36))|(1<<(PCREParserEndOfSubject-36))|(1<<(PCREParserPreviousMatchInSubject-36))|(1<<(PCREParserResetStartMatch-36))|(1<<(PCREParserSubroutineOrNamedReferenceStartG-36))|(1<<(PCREParserNamedReferenceStartK-36))|(1<<(PCREParserOpenParen-36))|(1<<(PCREParserLessThan-36))|(1<<(PCREParserGreaterThan-36))|(1<<(PCREParserSingleQuote-36))|(1<<(PCREParserUnderscore-36))|(1<<(PCREParserColon-36))|(1<<(PCREParserHash-36))|(1<<(PCREParserEquals-36))|(1<<(PCREParserExclamation-36))|(1<<(PCREParserAmpersand-36))|(1<<(PCREParserALC-36))|(1<<(PCREParserBLC-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(PCREParserCLC-68))|(1<<(PCREParserDLC-68))|(1<<(PCREParserELC-68))|(1<<(PCREParserFLC-68))|(1<<(PCREParserGLC-68))|(1<<(PCREParserHLC-68))|(1<<(PCREParserILC-68))|(1<<(PCREParserJLC-68))|(1<<(PCREParserKLC-68))|(1<<(PCREParserLLC-68))|(1<<(PCREParserMLC-68))|(1<<(PCREParserNLC-68))|(1<<(PCREParserOLC-68))|(1<<(PCREParserPLC-68))|(1<<(PCREParserQLC-68))|(1<<(PCREParserRLC-68))|(1<<(PCREParserSLC-68))|(1<<(PCREParserTLC-68))|(1<<(PCREParserULC-68))|(1<<(PCREParserVLC-68))|(1<<(PCREParserWLC-68))|(1<<(PCREParserXLC-68))|(1<<(PCREParserYLC-68))|(1<<(PCREParserZLC-68))|(1<<(PCREParserAUC-68))|(1<<(PCREParserBUC-68))|(1<<(PCREParserCUC-68))|(1<<(PCREParserDUC-68))|(1<<(PCREParserEUC-68))|(1<<(PCREParserFUC-68))|(1<<(PCREParserGUC-68))|(1<<(PCREParserHUC-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(PCREParserIUC-100))|(1<<(PCREParserJUC-100))|(1<<(PCREParserKUC-100))|(1<<(PCREParserLUC-100))|(1<<(PCREParserMUC-100))|(1<<(PCREParserNUC-100))|(1<<(PCREParserOUC-100))|(1<<(PCREParserPUC-100))|(1<<(PCREParserQUC-100))|(1<<(PCREParserRUC-100))|(1<<(PCREParserSUC-100))|(1<<(PCREParserTUC-100))|(1<<(PCREParserUUC-100))|(1<<(PCREParserVUC-100))|(1<<(PCREParserWUC-100))|(1<<(PCREParserXUC-100))|(1<<(PCREParserYUC-100))|(1<<(PCREParserZUC-100))|(1<<(PCREParserD1-100))|(1<<(PCREParserD2-100))|(1<<(PCREParserD3-100))|(1<<(PCREParserD4-100))|(1<<(PCREParserD5-100))|(1<<(PCREParserD6-100))|(1<<(PCREParserD7-100))|(1<<(PCREParserD8-100))|(1<<(PCREParserD9-100))|(1<<(PCREParserD0-100))|(1<<(PCREParserOtherChar-100)))) != 0) {
		{
			p.SetState(112)
			p.Element()
		}

		p.SetState(117)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_element
	return p
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *ElementContext) Quantifier() IQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantifierContext)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitElement(s)
	}
}

func (s *ElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Element() (localctx IElementContext) {
	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, PCREParserRULE_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(118)
		p.Atom()
	}
	p.SetState(120)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(119)
			p.Quantifier()
		}

	}

	return localctx
}

// IQuantifierContext is an interface to support dynamic dispatch.
type IQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantifierContext differentiates from other interfaces.
	IsQuantifierContext()
}

type QuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifierContext() *QuantifierContext {
	var p = new(QuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_quantifier
	return p
}

func (*QuantifierContext) IsQuantifierContext() {}

func NewQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifierContext {
	var p = new(QuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_quantifier

	return p
}

func (s *QuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifierContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *QuantifierContext) Quantifier_type() IQuantifier_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantifier_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantifier_typeContext)
}

func (s *QuantifierContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *QuantifierContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *QuantifierContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenBrace, 0)
}

func (s *QuantifierContext) AllNumber() []INumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberContext)(nil)).Elem())
	var tst = make([]INumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberContext)
		}
	}

	return tst
}

func (s *QuantifierContext) Number(i int) INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *QuantifierContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseBrace, 0)
}

func (s *QuantifierContext) Comma() antlr.TerminalNode {
	return s.GetToken(PCREParserComma, 0)
}

func (s *QuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterQuantifier(s)
	}
}

func (s *QuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitQuantifier(s)
	}
}

func (s *QuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Quantifier() (localctx IQuantifierContext) {
	localctx = NewQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PCREParserRULE_quantifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(146)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(122)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(123)
			p.Quantifier_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(124)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(125)
			p.Quantifier_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(126)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(127)
			p.Quantifier_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(128)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(129)
			p.Number()
		}
		{
			p.SetState(130)
			p.Match(PCREParserCloseBrace)
		}
		{
			p.SetState(131)
			p.Quantifier_type()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(133)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(134)
			p.Number()
		}
		{
			p.SetState(135)
			p.Match(PCREParserComma)
		}
		{
			p.SetState(136)
			p.Match(PCREParserCloseBrace)
		}
		{
			p.SetState(137)
			p.Quantifier_type()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(139)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(140)
			p.Number()
		}
		{
			p.SetState(141)
			p.Match(PCREParserComma)
		}
		{
			p.SetState(142)
			p.Number()
		}
		{
			p.SetState(143)
			p.Match(PCREParserCloseBrace)
		}
		{
			p.SetState(144)
			p.Quantifier_type()
		}

	}

	return localctx
}

// IQuantifier_typeContext is an interface to support dynamic dispatch.
type IQuantifier_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantifier_typeContext differentiates from other interfaces.
	IsQuantifier_typeContext()
}

type Quantifier_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifier_typeContext() *Quantifier_typeContext {
	var p = new(Quantifier_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_quantifier_type
	return p
}

func (*Quantifier_typeContext) IsQuantifier_typeContext() {}

func NewQuantifier_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quantifier_typeContext {
	var p = new(Quantifier_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_quantifier_type

	return p
}

func (s *Quantifier_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Quantifier_typeContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *Quantifier_typeContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Quantifier_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quantifier_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quantifier_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterQuantifier_type(s)
	}
}

func (s *Quantifier_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitQuantifier_type(s)
	}
}

func (s *Quantifier_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitQuantifier_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Quantifier_type() (localctx IQuantifier_typeContext) {
	localctx = NewQuantifier_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PCREParserRULE_quantifier_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(151)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserPlus:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(148)
			p.Match(PCREParserPlus)
		}

	case PCREParserQuestionMark:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(149)
			p.Match(PCREParserQuestionMark)
		}

	case PCREParserT__0, PCREParserQuoted, PCREParserBlockQuoted, PCREParserBellChar, PCREParserControlChar, PCREParserEscapeChar, PCREParserFormFeed, PCREParserNewLine, PCREParserCarriageReturn, PCREParserTab, PCREParserBackslash, PCREParserHexChar, PCREParserDot, PCREParserOneDataUnit, PCREParserDecimalDigit, PCREParserNotDecimalDigit, PCREParserHorizontalWhiteSpace, PCREParserNotHorizontalWhiteSpace, PCREParserNotNewLine, PCREParserCharWithProperty, PCREParserCharWithoutProperty, PCREParserNewLineSequence, PCREParserWhiteSpace, PCREParserNotWhiteSpace, PCREParserVerticalWhiteSpace, PCREParserNotVerticalWhiteSpace, PCREParserWordChar, PCREParserNotWordChar, PCREParserExtendedUnicodeChar, PCREParserCharacterClassStart, PCREParserCharacterClassEnd, PCREParserCaret, PCREParserHyphen, PCREParserPOSIXNamedSet, PCREParserPOSIXNegatedNamedSet, PCREParserOpenBrace, PCREParserCloseBrace, PCREParserComma, PCREParserWordBoundary, PCREParserNonWordBoundary, PCREParserStartOfSubject, PCREParserEndOfSubjectOrLine, PCREParserEndOfSubjectOrLineEndOfSubject, PCREParserEndOfSubject, PCREParserPreviousMatchInSubject, PCREParserResetStartMatch, PCREParserSubroutineOrNamedReferenceStartG, PCREParserNamedReferenceStartK, PCREParserPipe, PCREParserOpenParen, PCREParserCloseParen, PCREParserLessThan, PCREParserGreaterThan, PCREParserSingleQuote, PCREParserUnderscore, PCREParserColon, PCREParserHash, PCREParserEquals, PCREParserExclamation, PCREParserAmpersand, PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0, PCREParserOtherChar:
		p.EnterOuterAlt(localctx, 3)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICharacter_classContext is an interface to support dynamic dispatch.
type ICharacter_classContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacter_classContext differentiates from other interfaces.
	IsCharacter_classContext()
}

type Character_classContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacter_classContext() *Character_classContext {
	var p = new(Character_classContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_character_class
	return p
}

func (*Character_classContext) IsCharacter_classContext() {}

func NewCharacter_classContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Character_classContext {
	var p = new(Character_classContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_character_class

	return p
}

func (s *Character_classContext) GetParser() antlr.Parser { return s.parser }

func (s *Character_classContext) CharacterClassStart() antlr.TerminalNode {
	return s.GetToken(PCREParserCharacterClassStart, 0)
}

func (s *Character_classContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *Character_classContext) AllCharacterClassEnd() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCharacterClassEnd)
}

func (s *Character_classContext) CharacterClassEnd(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCharacterClassEnd, i)
}

func (s *Character_classContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *Character_classContext) AllCc_atom() []ICc_atomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICc_atomContext)(nil)).Elem())
	var tst = make([]ICc_atomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICc_atomContext)
		}
	}

	return tst
}

func (s *Character_classContext) Cc_atom(i int) ICc_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICc_atomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICc_atomContext)
}

func (s *Character_classContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Character_classContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Character_classContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCharacter_class(s)
	}
}

func (s *Character_classContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCharacter_class(s)
	}
}

func (s *Character_classContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCharacter_class(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Character_class() (localctx ICharacter_classContext) {
	localctx = NewCharacter_classContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PCREParserRULE_character_class)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(210)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(153)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(154)
			p.Match(PCREParserCaret)
		}
		{
			p.SetState(155)
			p.Match(PCREParserCharacterClassEnd)
		}
		{
			p.SetState(156)
			p.Match(PCREParserHyphen)
		}
		p.SetState(158)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-4)&-(0x1f+1)) == 0 && ((1<<uint((_la-4)))&((1<<(PCREParserQuoted-4))|(1<<(PCREParserBlockQuoted-4))|(1<<(PCREParserBellChar-4))|(1<<(PCREParserControlChar-4))|(1<<(PCREParserEscapeChar-4))|(1<<(PCREParserFormFeed-4))|(1<<(PCREParserNewLine-4))|(1<<(PCREParserCarriageReturn-4))|(1<<(PCREParserTab-4))|(1<<(PCREParserBackslash-4))|(1<<(PCREParserHexChar-4))|(1<<(PCREParserDot-4))|(1<<(PCREParserDecimalDigit-4))|(1<<(PCREParserNotDecimalDigit-4))|(1<<(PCREParserHorizontalWhiteSpace-4))|(1<<(PCREParserNotHorizontalWhiteSpace-4))|(1<<(PCREParserNotNewLine-4))|(1<<(PCREParserCharWithProperty-4))|(1<<(PCREParserCharWithoutProperty-4))|(1<<(PCREParserNewLineSequence-4))|(1<<(PCREParserWhiteSpace-4))|(1<<(PCREParserNotWhiteSpace-4))|(1<<(PCREParserVerticalWhiteSpace-4))|(1<<(PCREParserNotVerticalWhiteSpace-4))|(1<<(PCREParserWordChar-4))|(1<<(PCREParserNotWordChar-4))|(1<<(PCREParserCharacterClassStart-4))|(1<<(PCREParserCaret-4))|(1<<(PCREParserHyphen-4)))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PCREParserPOSIXNamedSet-36))|(1<<(PCREParserPOSIXNegatedNamedSet-36))|(1<<(PCREParserQuestionMark-36))|(1<<(PCREParserPlus-36))|(1<<(PCREParserStar-36))|(1<<(PCREParserOpenBrace-36))|(1<<(PCREParserCloseBrace-36))|(1<<(PCREParserComma-36))|(1<<(PCREParserWordBoundary-36))|(1<<(PCREParserEndOfSubjectOrLine-36))|(1<<(PCREParserPipe-36))|(1<<(PCREParserOpenParen-36))|(1<<(PCREParserCloseParen-36))|(1<<(PCREParserLessThan-36))|(1<<(PCREParserGreaterThan-36))|(1<<(PCREParserSingleQuote-36))|(1<<(PCREParserUnderscore-36))|(1<<(PCREParserColon-36))|(1<<(PCREParserHash-36))|(1<<(PCREParserEquals-36))|(1<<(PCREParserExclamation-36))|(1<<(PCREParserAmpersand-36))|(1<<(PCREParserALC-36))|(1<<(PCREParserBLC-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(PCREParserCLC-68))|(1<<(PCREParserDLC-68))|(1<<(PCREParserELC-68))|(1<<(PCREParserFLC-68))|(1<<(PCREParserGLC-68))|(1<<(PCREParserHLC-68))|(1<<(PCREParserILC-68))|(1<<(PCREParserJLC-68))|(1<<(PCREParserKLC-68))|(1<<(PCREParserLLC-68))|(1<<(PCREParserMLC-68))|(1<<(PCREParserNLC-68))|(1<<(PCREParserOLC-68))|(1<<(PCREParserPLC-68))|(1<<(PCREParserQLC-68))|(1<<(PCREParserRLC-68))|(1<<(PCREParserSLC-68))|(1<<(PCREParserTLC-68))|(1<<(PCREParserULC-68))|(1<<(PCREParserVLC-68))|(1<<(PCREParserWLC-68))|(1<<(PCREParserXLC-68))|(1<<(PCREParserYLC-68))|(1<<(PCREParserZLC-68))|(1<<(PCREParserAUC-68))|(1<<(PCREParserBUC-68))|(1<<(PCREParserCUC-68))|(1<<(PCREParserDUC-68))|(1<<(PCREParserEUC-68))|(1<<(PCREParserFUC-68))|(1<<(PCREParserGUC-68))|(1<<(PCREParserHUC-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(PCREParserIUC-100))|(1<<(PCREParserJUC-100))|(1<<(PCREParserKUC-100))|(1<<(PCREParserLUC-100))|(1<<(PCREParserMUC-100))|(1<<(PCREParserNUC-100))|(1<<(PCREParserOUC-100))|(1<<(PCREParserPUC-100))|(1<<(PCREParserQUC-100))|(1<<(PCREParserRUC-100))|(1<<(PCREParserSUC-100))|(1<<(PCREParserTUC-100))|(1<<(PCREParserUUC-100))|(1<<(PCREParserVUC-100))|(1<<(PCREParserWUC-100))|(1<<(PCREParserXUC-100))|(1<<(PCREParserYUC-100))|(1<<(PCREParserZUC-100))|(1<<(PCREParserD1-100))|(1<<(PCREParserD2-100))|(1<<(PCREParserD3-100))|(1<<(PCREParserD4-100))|(1<<(PCREParserD5-100))|(1<<(PCREParserD6-100))|(1<<(PCREParserD7-100))|(1<<(PCREParserD8-100))|(1<<(PCREParserD9-100))|(1<<(PCREParserD0-100))|(1<<(PCREParserOtherChar-100)))) != 0) {
			{
				p.SetState(157)
				p.Cc_atom()
			}

			p.SetState(160)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(162)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(164)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(165)
			p.Match(PCREParserCaret)
		}
		{
			p.SetState(166)
			p.Match(PCREParserCharacterClassEnd)
		}
		p.SetState(170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-4)&-(0x1f+1)) == 0 && ((1<<uint((_la-4)))&((1<<(PCREParserQuoted-4))|(1<<(PCREParserBlockQuoted-4))|(1<<(PCREParserBellChar-4))|(1<<(PCREParserControlChar-4))|(1<<(PCREParserEscapeChar-4))|(1<<(PCREParserFormFeed-4))|(1<<(PCREParserNewLine-4))|(1<<(PCREParserCarriageReturn-4))|(1<<(PCREParserTab-4))|(1<<(PCREParserBackslash-4))|(1<<(PCREParserHexChar-4))|(1<<(PCREParserDot-4))|(1<<(PCREParserDecimalDigit-4))|(1<<(PCREParserNotDecimalDigit-4))|(1<<(PCREParserHorizontalWhiteSpace-4))|(1<<(PCREParserNotHorizontalWhiteSpace-4))|(1<<(PCREParserNotNewLine-4))|(1<<(PCREParserCharWithProperty-4))|(1<<(PCREParserCharWithoutProperty-4))|(1<<(PCREParserNewLineSequence-4))|(1<<(PCREParserWhiteSpace-4))|(1<<(PCREParserNotWhiteSpace-4))|(1<<(PCREParserVerticalWhiteSpace-4))|(1<<(PCREParserNotVerticalWhiteSpace-4))|(1<<(PCREParserWordChar-4))|(1<<(PCREParserNotWordChar-4))|(1<<(PCREParserCharacterClassStart-4))|(1<<(PCREParserCaret-4))|(1<<(PCREParserHyphen-4)))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PCREParserPOSIXNamedSet-36))|(1<<(PCREParserPOSIXNegatedNamedSet-36))|(1<<(PCREParserQuestionMark-36))|(1<<(PCREParserPlus-36))|(1<<(PCREParserStar-36))|(1<<(PCREParserOpenBrace-36))|(1<<(PCREParserCloseBrace-36))|(1<<(PCREParserComma-36))|(1<<(PCREParserWordBoundary-36))|(1<<(PCREParserEndOfSubjectOrLine-36))|(1<<(PCREParserPipe-36))|(1<<(PCREParserOpenParen-36))|(1<<(PCREParserCloseParen-36))|(1<<(PCREParserLessThan-36))|(1<<(PCREParserGreaterThan-36))|(1<<(PCREParserSingleQuote-36))|(1<<(PCREParserUnderscore-36))|(1<<(PCREParserColon-36))|(1<<(PCREParserHash-36))|(1<<(PCREParserEquals-36))|(1<<(PCREParserExclamation-36))|(1<<(PCREParserAmpersand-36))|(1<<(PCREParserALC-36))|(1<<(PCREParserBLC-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(PCREParserCLC-68))|(1<<(PCREParserDLC-68))|(1<<(PCREParserELC-68))|(1<<(PCREParserFLC-68))|(1<<(PCREParserGLC-68))|(1<<(PCREParserHLC-68))|(1<<(PCREParserILC-68))|(1<<(PCREParserJLC-68))|(1<<(PCREParserKLC-68))|(1<<(PCREParserLLC-68))|(1<<(PCREParserMLC-68))|(1<<(PCREParserNLC-68))|(1<<(PCREParserOLC-68))|(1<<(PCREParserPLC-68))|(1<<(PCREParserQLC-68))|(1<<(PCREParserRLC-68))|(1<<(PCREParserSLC-68))|(1<<(PCREParserTLC-68))|(1<<(PCREParserULC-68))|(1<<(PCREParserVLC-68))|(1<<(PCREParserWLC-68))|(1<<(PCREParserXLC-68))|(1<<(PCREParserYLC-68))|(1<<(PCREParserZLC-68))|(1<<(PCREParserAUC-68))|(1<<(PCREParserBUC-68))|(1<<(PCREParserCUC-68))|(1<<(PCREParserDUC-68))|(1<<(PCREParserEUC-68))|(1<<(PCREParserFUC-68))|(1<<(PCREParserGUC-68))|(1<<(PCREParserHUC-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(PCREParserIUC-100))|(1<<(PCREParserJUC-100))|(1<<(PCREParserKUC-100))|(1<<(PCREParserLUC-100))|(1<<(PCREParserMUC-100))|(1<<(PCREParserNUC-100))|(1<<(PCREParserOUC-100))|(1<<(PCREParserPUC-100))|(1<<(PCREParserQUC-100))|(1<<(PCREParserRUC-100))|(1<<(PCREParserSUC-100))|(1<<(PCREParserTUC-100))|(1<<(PCREParserUUC-100))|(1<<(PCREParserVUC-100))|(1<<(PCREParserWUC-100))|(1<<(PCREParserXUC-100))|(1<<(PCREParserYUC-100))|(1<<(PCREParserZUC-100))|(1<<(PCREParserD1-100))|(1<<(PCREParserD2-100))|(1<<(PCREParserD3-100))|(1<<(PCREParserD4-100))|(1<<(PCREParserD5-100))|(1<<(PCREParserD6-100))|(1<<(PCREParserD7-100))|(1<<(PCREParserD8-100))|(1<<(PCREParserD9-100))|(1<<(PCREParserD0-100))|(1<<(PCREParserOtherChar-100)))) != 0) {
			{
				p.SetState(167)
				p.Cc_atom()
			}

			p.SetState(172)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(173)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(174)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(175)
			p.Match(PCREParserCaret)
		}
		p.SetState(177)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-4)&-(0x1f+1)) == 0 && ((1<<uint((_la-4)))&((1<<(PCREParserQuoted-4))|(1<<(PCREParserBlockQuoted-4))|(1<<(PCREParserBellChar-4))|(1<<(PCREParserControlChar-4))|(1<<(PCREParserEscapeChar-4))|(1<<(PCREParserFormFeed-4))|(1<<(PCREParserNewLine-4))|(1<<(PCREParserCarriageReturn-4))|(1<<(PCREParserTab-4))|(1<<(PCREParserBackslash-4))|(1<<(PCREParserHexChar-4))|(1<<(PCREParserDot-4))|(1<<(PCREParserDecimalDigit-4))|(1<<(PCREParserNotDecimalDigit-4))|(1<<(PCREParserHorizontalWhiteSpace-4))|(1<<(PCREParserNotHorizontalWhiteSpace-4))|(1<<(PCREParserNotNewLine-4))|(1<<(PCREParserCharWithProperty-4))|(1<<(PCREParserCharWithoutProperty-4))|(1<<(PCREParserNewLineSequence-4))|(1<<(PCREParserWhiteSpace-4))|(1<<(PCREParserNotWhiteSpace-4))|(1<<(PCREParserVerticalWhiteSpace-4))|(1<<(PCREParserNotVerticalWhiteSpace-4))|(1<<(PCREParserWordChar-4))|(1<<(PCREParserNotWordChar-4))|(1<<(PCREParserCharacterClassStart-4))|(1<<(PCREParserCaret-4))|(1<<(PCREParserHyphen-4)))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PCREParserPOSIXNamedSet-36))|(1<<(PCREParserPOSIXNegatedNamedSet-36))|(1<<(PCREParserQuestionMark-36))|(1<<(PCREParserPlus-36))|(1<<(PCREParserStar-36))|(1<<(PCREParserOpenBrace-36))|(1<<(PCREParserCloseBrace-36))|(1<<(PCREParserComma-36))|(1<<(PCREParserWordBoundary-36))|(1<<(PCREParserEndOfSubjectOrLine-36))|(1<<(PCREParserPipe-36))|(1<<(PCREParserOpenParen-36))|(1<<(PCREParserCloseParen-36))|(1<<(PCREParserLessThan-36))|(1<<(PCREParserGreaterThan-36))|(1<<(PCREParserSingleQuote-36))|(1<<(PCREParserUnderscore-36))|(1<<(PCREParserColon-36))|(1<<(PCREParserHash-36))|(1<<(PCREParserEquals-36))|(1<<(PCREParserExclamation-36))|(1<<(PCREParserAmpersand-36))|(1<<(PCREParserALC-36))|(1<<(PCREParserBLC-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(PCREParserCLC-68))|(1<<(PCREParserDLC-68))|(1<<(PCREParserELC-68))|(1<<(PCREParserFLC-68))|(1<<(PCREParserGLC-68))|(1<<(PCREParserHLC-68))|(1<<(PCREParserILC-68))|(1<<(PCREParserJLC-68))|(1<<(PCREParserKLC-68))|(1<<(PCREParserLLC-68))|(1<<(PCREParserMLC-68))|(1<<(PCREParserNLC-68))|(1<<(PCREParserOLC-68))|(1<<(PCREParserPLC-68))|(1<<(PCREParserQLC-68))|(1<<(PCREParserRLC-68))|(1<<(PCREParserSLC-68))|(1<<(PCREParserTLC-68))|(1<<(PCREParserULC-68))|(1<<(PCREParserVLC-68))|(1<<(PCREParserWLC-68))|(1<<(PCREParserXLC-68))|(1<<(PCREParserYLC-68))|(1<<(PCREParserZLC-68))|(1<<(PCREParserAUC-68))|(1<<(PCREParserBUC-68))|(1<<(PCREParserCUC-68))|(1<<(PCREParserDUC-68))|(1<<(PCREParserEUC-68))|(1<<(PCREParserFUC-68))|(1<<(PCREParserGUC-68))|(1<<(PCREParserHUC-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(PCREParserIUC-100))|(1<<(PCREParserJUC-100))|(1<<(PCREParserKUC-100))|(1<<(PCREParserLUC-100))|(1<<(PCREParserMUC-100))|(1<<(PCREParserNUC-100))|(1<<(PCREParserOUC-100))|(1<<(PCREParserPUC-100))|(1<<(PCREParserQUC-100))|(1<<(PCREParserRUC-100))|(1<<(PCREParserSUC-100))|(1<<(PCREParserTUC-100))|(1<<(PCREParserUUC-100))|(1<<(PCREParserVUC-100))|(1<<(PCREParserWUC-100))|(1<<(PCREParserXUC-100))|(1<<(PCREParserYUC-100))|(1<<(PCREParserZUC-100))|(1<<(PCREParserD1-100))|(1<<(PCREParserD2-100))|(1<<(PCREParserD3-100))|(1<<(PCREParserD4-100))|(1<<(PCREParserD5-100))|(1<<(PCREParserD6-100))|(1<<(PCREParserD7-100))|(1<<(PCREParserD8-100))|(1<<(PCREParserD9-100))|(1<<(PCREParserD0-100))|(1<<(PCREParserOtherChar-100)))) != 0) {
			{
				p.SetState(176)
				p.Cc_atom()
			}

			p.SetState(179)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(181)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(183)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(184)
			p.Match(PCREParserCharacterClassEnd)
		}
		{
			p.SetState(185)
			p.Match(PCREParserHyphen)
		}
		p.SetState(187)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-4)&-(0x1f+1)) == 0 && ((1<<uint((_la-4)))&((1<<(PCREParserQuoted-4))|(1<<(PCREParserBlockQuoted-4))|(1<<(PCREParserBellChar-4))|(1<<(PCREParserControlChar-4))|(1<<(PCREParserEscapeChar-4))|(1<<(PCREParserFormFeed-4))|(1<<(PCREParserNewLine-4))|(1<<(PCREParserCarriageReturn-4))|(1<<(PCREParserTab-4))|(1<<(PCREParserBackslash-4))|(1<<(PCREParserHexChar-4))|(1<<(PCREParserDot-4))|(1<<(PCREParserDecimalDigit-4))|(1<<(PCREParserNotDecimalDigit-4))|(1<<(PCREParserHorizontalWhiteSpace-4))|(1<<(PCREParserNotHorizontalWhiteSpace-4))|(1<<(PCREParserNotNewLine-4))|(1<<(PCREParserCharWithProperty-4))|(1<<(PCREParserCharWithoutProperty-4))|(1<<(PCREParserNewLineSequence-4))|(1<<(PCREParserWhiteSpace-4))|(1<<(PCREParserNotWhiteSpace-4))|(1<<(PCREParserVerticalWhiteSpace-4))|(1<<(PCREParserNotVerticalWhiteSpace-4))|(1<<(PCREParserWordChar-4))|(1<<(PCREParserNotWordChar-4))|(1<<(PCREParserCharacterClassStart-4))|(1<<(PCREParserCaret-4))|(1<<(PCREParserHyphen-4)))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PCREParserPOSIXNamedSet-36))|(1<<(PCREParserPOSIXNegatedNamedSet-36))|(1<<(PCREParserQuestionMark-36))|(1<<(PCREParserPlus-36))|(1<<(PCREParserStar-36))|(1<<(PCREParserOpenBrace-36))|(1<<(PCREParserCloseBrace-36))|(1<<(PCREParserComma-36))|(1<<(PCREParserWordBoundary-36))|(1<<(PCREParserEndOfSubjectOrLine-36))|(1<<(PCREParserPipe-36))|(1<<(PCREParserOpenParen-36))|(1<<(PCREParserCloseParen-36))|(1<<(PCREParserLessThan-36))|(1<<(PCREParserGreaterThan-36))|(1<<(PCREParserSingleQuote-36))|(1<<(PCREParserUnderscore-36))|(1<<(PCREParserColon-36))|(1<<(PCREParserHash-36))|(1<<(PCREParserEquals-36))|(1<<(PCREParserExclamation-36))|(1<<(PCREParserAmpersand-36))|(1<<(PCREParserALC-36))|(1<<(PCREParserBLC-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(PCREParserCLC-68))|(1<<(PCREParserDLC-68))|(1<<(PCREParserELC-68))|(1<<(PCREParserFLC-68))|(1<<(PCREParserGLC-68))|(1<<(PCREParserHLC-68))|(1<<(PCREParserILC-68))|(1<<(PCREParserJLC-68))|(1<<(PCREParserKLC-68))|(1<<(PCREParserLLC-68))|(1<<(PCREParserMLC-68))|(1<<(PCREParserNLC-68))|(1<<(PCREParserOLC-68))|(1<<(PCREParserPLC-68))|(1<<(PCREParserQLC-68))|(1<<(PCREParserRLC-68))|(1<<(PCREParserSLC-68))|(1<<(PCREParserTLC-68))|(1<<(PCREParserULC-68))|(1<<(PCREParserVLC-68))|(1<<(PCREParserWLC-68))|(1<<(PCREParserXLC-68))|(1<<(PCREParserYLC-68))|(1<<(PCREParserZLC-68))|(1<<(PCREParserAUC-68))|(1<<(PCREParserBUC-68))|(1<<(PCREParserCUC-68))|(1<<(PCREParserDUC-68))|(1<<(PCREParserEUC-68))|(1<<(PCREParserFUC-68))|(1<<(PCREParserGUC-68))|(1<<(PCREParserHUC-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(PCREParserIUC-100))|(1<<(PCREParserJUC-100))|(1<<(PCREParserKUC-100))|(1<<(PCREParserLUC-100))|(1<<(PCREParserMUC-100))|(1<<(PCREParserNUC-100))|(1<<(PCREParserOUC-100))|(1<<(PCREParserPUC-100))|(1<<(PCREParserQUC-100))|(1<<(PCREParserRUC-100))|(1<<(PCREParserSUC-100))|(1<<(PCREParserTUC-100))|(1<<(PCREParserUUC-100))|(1<<(PCREParserVUC-100))|(1<<(PCREParserWUC-100))|(1<<(PCREParserXUC-100))|(1<<(PCREParserYUC-100))|(1<<(PCREParserZUC-100))|(1<<(PCREParserD1-100))|(1<<(PCREParserD2-100))|(1<<(PCREParserD3-100))|(1<<(PCREParserD4-100))|(1<<(PCREParserD5-100))|(1<<(PCREParserD6-100))|(1<<(PCREParserD7-100))|(1<<(PCREParserD8-100))|(1<<(PCREParserD9-100))|(1<<(PCREParserD0-100))|(1<<(PCREParserOtherChar-100)))) != 0) {
			{
				p.SetState(186)
				p.Cc_atom()
			}

			p.SetState(189)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(191)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(193)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(194)
			p.Match(PCREParserCharacterClassEnd)
		}
		p.SetState(198)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-4)&-(0x1f+1)) == 0 && ((1<<uint((_la-4)))&((1<<(PCREParserQuoted-4))|(1<<(PCREParserBlockQuoted-4))|(1<<(PCREParserBellChar-4))|(1<<(PCREParserControlChar-4))|(1<<(PCREParserEscapeChar-4))|(1<<(PCREParserFormFeed-4))|(1<<(PCREParserNewLine-4))|(1<<(PCREParserCarriageReturn-4))|(1<<(PCREParserTab-4))|(1<<(PCREParserBackslash-4))|(1<<(PCREParserHexChar-4))|(1<<(PCREParserDot-4))|(1<<(PCREParserDecimalDigit-4))|(1<<(PCREParserNotDecimalDigit-4))|(1<<(PCREParserHorizontalWhiteSpace-4))|(1<<(PCREParserNotHorizontalWhiteSpace-4))|(1<<(PCREParserNotNewLine-4))|(1<<(PCREParserCharWithProperty-4))|(1<<(PCREParserCharWithoutProperty-4))|(1<<(PCREParserNewLineSequence-4))|(1<<(PCREParserWhiteSpace-4))|(1<<(PCREParserNotWhiteSpace-4))|(1<<(PCREParserVerticalWhiteSpace-4))|(1<<(PCREParserNotVerticalWhiteSpace-4))|(1<<(PCREParserWordChar-4))|(1<<(PCREParserNotWordChar-4))|(1<<(PCREParserCharacterClassStart-4))|(1<<(PCREParserCaret-4))|(1<<(PCREParserHyphen-4)))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PCREParserPOSIXNamedSet-36))|(1<<(PCREParserPOSIXNegatedNamedSet-36))|(1<<(PCREParserQuestionMark-36))|(1<<(PCREParserPlus-36))|(1<<(PCREParserStar-36))|(1<<(PCREParserOpenBrace-36))|(1<<(PCREParserCloseBrace-36))|(1<<(PCREParserComma-36))|(1<<(PCREParserWordBoundary-36))|(1<<(PCREParserEndOfSubjectOrLine-36))|(1<<(PCREParserPipe-36))|(1<<(PCREParserOpenParen-36))|(1<<(PCREParserCloseParen-36))|(1<<(PCREParserLessThan-36))|(1<<(PCREParserGreaterThan-36))|(1<<(PCREParserSingleQuote-36))|(1<<(PCREParserUnderscore-36))|(1<<(PCREParserColon-36))|(1<<(PCREParserHash-36))|(1<<(PCREParserEquals-36))|(1<<(PCREParserExclamation-36))|(1<<(PCREParserAmpersand-36))|(1<<(PCREParserALC-36))|(1<<(PCREParserBLC-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(PCREParserCLC-68))|(1<<(PCREParserDLC-68))|(1<<(PCREParserELC-68))|(1<<(PCREParserFLC-68))|(1<<(PCREParserGLC-68))|(1<<(PCREParserHLC-68))|(1<<(PCREParserILC-68))|(1<<(PCREParserJLC-68))|(1<<(PCREParserKLC-68))|(1<<(PCREParserLLC-68))|(1<<(PCREParserMLC-68))|(1<<(PCREParserNLC-68))|(1<<(PCREParserOLC-68))|(1<<(PCREParserPLC-68))|(1<<(PCREParserQLC-68))|(1<<(PCREParserRLC-68))|(1<<(PCREParserSLC-68))|(1<<(PCREParserTLC-68))|(1<<(PCREParserULC-68))|(1<<(PCREParserVLC-68))|(1<<(PCREParserWLC-68))|(1<<(PCREParserXLC-68))|(1<<(PCREParserYLC-68))|(1<<(PCREParserZLC-68))|(1<<(PCREParserAUC-68))|(1<<(PCREParserBUC-68))|(1<<(PCREParserCUC-68))|(1<<(PCREParserDUC-68))|(1<<(PCREParserEUC-68))|(1<<(PCREParserFUC-68))|(1<<(PCREParserGUC-68))|(1<<(PCREParserHUC-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(PCREParserIUC-100))|(1<<(PCREParserJUC-100))|(1<<(PCREParserKUC-100))|(1<<(PCREParserLUC-100))|(1<<(PCREParserMUC-100))|(1<<(PCREParserNUC-100))|(1<<(PCREParserOUC-100))|(1<<(PCREParserPUC-100))|(1<<(PCREParserQUC-100))|(1<<(PCREParserRUC-100))|(1<<(PCREParserSUC-100))|(1<<(PCREParserTUC-100))|(1<<(PCREParserUUC-100))|(1<<(PCREParserVUC-100))|(1<<(PCREParserWUC-100))|(1<<(PCREParserXUC-100))|(1<<(PCREParserYUC-100))|(1<<(PCREParserZUC-100))|(1<<(PCREParserD1-100))|(1<<(PCREParserD2-100))|(1<<(PCREParserD3-100))|(1<<(PCREParserD4-100))|(1<<(PCREParserD5-100))|(1<<(PCREParserD6-100))|(1<<(PCREParserD7-100))|(1<<(PCREParserD8-100))|(1<<(PCREParserD9-100))|(1<<(PCREParserD0-100))|(1<<(PCREParserOtherChar-100)))) != 0) {
			{
				p.SetState(195)
				p.Cc_atom()
			}

			p.SetState(200)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(201)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(202)
			p.Match(PCREParserCharacterClassStart)
		}
		p.SetState(204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-4)&-(0x1f+1)) == 0 && ((1<<uint((_la-4)))&((1<<(PCREParserQuoted-4))|(1<<(PCREParserBlockQuoted-4))|(1<<(PCREParserBellChar-4))|(1<<(PCREParserControlChar-4))|(1<<(PCREParserEscapeChar-4))|(1<<(PCREParserFormFeed-4))|(1<<(PCREParserNewLine-4))|(1<<(PCREParserCarriageReturn-4))|(1<<(PCREParserTab-4))|(1<<(PCREParserBackslash-4))|(1<<(PCREParserHexChar-4))|(1<<(PCREParserDot-4))|(1<<(PCREParserDecimalDigit-4))|(1<<(PCREParserNotDecimalDigit-4))|(1<<(PCREParserHorizontalWhiteSpace-4))|(1<<(PCREParserNotHorizontalWhiteSpace-4))|(1<<(PCREParserNotNewLine-4))|(1<<(PCREParserCharWithProperty-4))|(1<<(PCREParserCharWithoutProperty-4))|(1<<(PCREParserNewLineSequence-4))|(1<<(PCREParserWhiteSpace-4))|(1<<(PCREParserNotWhiteSpace-4))|(1<<(PCREParserVerticalWhiteSpace-4))|(1<<(PCREParserNotVerticalWhiteSpace-4))|(1<<(PCREParserWordChar-4))|(1<<(PCREParserNotWordChar-4))|(1<<(PCREParserCharacterClassStart-4))|(1<<(PCREParserCaret-4))|(1<<(PCREParserHyphen-4)))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PCREParserPOSIXNamedSet-36))|(1<<(PCREParserPOSIXNegatedNamedSet-36))|(1<<(PCREParserQuestionMark-36))|(1<<(PCREParserPlus-36))|(1<<(PCREParserStar-36))|(1<<(PCREParserOpenBrace-36))|(1<<(PCREParserCloseBrace-36))|(1<<(PCREParserComma-36))|(1<<(PCREParserWordBoundary-36))|(1<<(PCREParserEndOfSubjectOrLine-36))|(1<<(PCREParserPipe-36))|(1<<(PCREParserOpenParen-36))|(1<<(PCREParserCloseParen-36))|(1<<(PCREParserLessThan-36))|(1<<(PCREParserGreaterThan-36))|(1<<(PCREParserSingleQuote-36))|(1<<(PCREParserUnderscore-36))|(1<<(PCREParserColon-36))|(1<<(PCREParserHash-36))|(1<<(PCREParserEquals-36))|(1<<(PCREParserExclamation-36))|(1<<(PCREParserAmpersand-36))|(1<<(PCREParserALC-36))|(1<<(PCREParserBLC-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(PCREParserCLC-68))|(1<<(PCREParserDLC-68))|(1<<(PCREParserELC-68))|(1<<(PCREParserFLC-68))|(1<<(PCREParserGLC-68))|(1<<(PCREParserHLC-68))|(1<<(PCREParserILC-68))|(1<<(PCREParserJLC-68))|(1<<(PCREParserKLC-68))|(1<<(PCREParserLLC-68))|(1<<(PCREParserMLC-68))|(1<<(PCREParserNLC-68))|(1<<(PCREParserOLC-68))|(1<<(PCREParserPLC-68))|(1<<(PCREParserQLC-68))|(1<<(PCREParserRLC-68))|(1<<(PCREParserSLC-68))|(1<<(PCREParserTLC-68))|(1<<(PCREParserULC-68))|(1<<(PCREParserVLC-68))|(1<<(PCREParserWLC-68))|(1<<(PCREParserXLC-68))|(1<<(PCREParserYLC-68))|(1<<(PCREParserZLC-68))|(1<<(PCREParserAUC-68))|(1<<(PCREParserBUC-68))|(1<<(PCREParserCUC-68))|(1<<(PCREParserDUC-68))|(1<<(PCREParserEUC-68))|(1<<(PCREParserFUC-68))|(1<<(PCREParserGUC-68))|(1<<(PCREParserHUC-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(PCREParserIUC-100))|(1<<(PCREParserJUC-100))|(1<<(PCREParserKUC-100))|(1<<(PCREParserLUC-100))|(1<<(PCREParserMUC-100))|(1<<(PCREParserNUC-100))|(1<<(PCREParserOUC-100))|(1<<(PCREParserPUC-100))|(1<<(PCREParserQUC-100))|(1<<(PCREParserRUC-100))|(1<<(PCREParserSUC-100))|(1<<(PCREParserTUC-100))|(1<<(PCREParserUUC-100))|(1<<(PCREParserVUC-100))|(1<<(PCREParserWUC-100))|(1<<(PCREParserXUC-100))|(1<<(PCREParserYUC-100))|(1<<(PCREParserZUC-100))|(1<<(PCREParserD1-100))|(1<<(PCREParserD2-100))|(1<<(PCREParserD3-100))|(1<<(PCREParserD4-100))|(1<<(PCREParserD5-100))|(1<<(PCREParserD6-100))|(1<<(PCREParserD7-100))|(1<<(PCREParserD8-100))|(1<<(PCREParserD9-100))|(1<<(PCREParserD0-100))|(1<<(PCREParserOtherChar-100)))) != 0) {
			{
				p.SetState(203)
				p.Cc_atom()
			}

			p.SetState(206)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(208)
			p.Match(PCREParserCharacterClassEnd)
		}

	}

	return localctx
}

// IBackreferenceContext is an interface to support dynamic dispatch.
type IBackreferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBackreferenceContext differentiates from other interfaces.
	IsBackreferenceContext()
}

type BackreferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackreferenceContext() *BackreferenceContext {
	var p = new(BackreferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_backreference
	return p
}

func (*BackreferenceContext) IsBackreferenceContext() {}

func NewBackreferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackreferenceContext {
	var p = new(BackreferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_backreference

	return p
}

func (s *BackreferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *BackreferenceContext) Backreference_or_octal() IBackreference_or_octalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackreference_or_octalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackreference_or_octalContext)
}

func (s *BackreferenceContext) SubroutineOrNamedReferenceStartG() antlr.TerminalNode {
	return s.GetToken(PCREParserSubroutineOrNamedReferenceStartG, 0)
}

func (s *BackreferenceContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *BackreferenceContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenBrace, 0)
}

func (s *BackreferenceContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseBrace, 0)
}

func (s *BackreferenceContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *BackreferenceContext) NamedReferenceStartK() antlr.TerminalNode {
	return s.GetToken(PCREParserNamedReferenceStartK, 0)
}

func (s *BackreferenceContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *BackreferenceContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *BackreferenceContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *BackreferenceContext) AllSingleQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSingleQuote)
}

func (s *BackreferenceContext) SingleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, i)
}

func (s *BackreferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackreferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackreferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBackreference(s)
	}
}

func (s *BackreferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBackreference(s)
	}
}

func (s *BackreferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitBackreference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Backreference() (localctx IBackreferenceContext) {
	localctx = NewBackreferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PCREParserRULE_backreference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(246)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(212)
			p.Backreference_or_octal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(213)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(214)
			p.Number()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(215)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(216)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(217)
			p.Number()
		}
		{
			p.SetState(218)
			p.Match(PCREParserCloseBrace)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(220)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(221)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(222)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(223)
			p.Number()
		}
		{
			p.SetState(224)
			p.Match(PCREParserCloseBrace)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(226)
			p.Match(PCREParserNamedReferenceStartK)
		}
		{
			p.SetState(227)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(228)
			p.Name()
		}
		{
			p.SetState(229)
			p.Match(PCREParserGreaterThan)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(231)
			p.Match(PCREParserNamedReferenceStartK)
		}
		{
			p.SetState(232)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(233)
			p.Name()
		}
		{
			p.SetState(234)
			p.Match(PCREParserSingleQuote)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(236)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(237)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(238)
			p.Name()
		}
		{
			p.SetState(239)
			p.Match(PCREParserCloseBrace)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(241)
			p.Match(PCREParserNamedReferenceStartK)
		}
		{
			p.SetState(242)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(243)
			p.Name()
		}
		{
			p.SetState(244)
			p.Match(PCREParserCloseBrace)
		}

	}

	return localctx
}

// IBackreference_or_octalContext is an interface to support dynamic dispatch.
type IBackreference_or_octalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBackreference_or_octalContext differentiates from other interfaces.
	IsBackreference_or_octalContext()
}

type Backreference_or_octalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackreference_or_octalContext() *Backreference_or_octalContext {
	var p = new(Backreference_or_octalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_backreference_or_octal
	return p
}

func (*Backreference_or_octalContext) IsBackreference_or_octalContext() {}

func NewBackreference_or_octalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backreference_or_octalContext {
	var p = new(Backreference_or_octalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_backreference_or_octal

	return p
}

func (s *Backreference_or_octalContext) GetParser() antlr.Parser { return s.parser }

func (s *Backreference_or_octalContext) Octal_char() IOctal_charContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctal_charContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctal_charContext)
}

func (s *Backreference_or_octalContext) Backslash() antlr.TerminalNode {
	return s.GetToken(PCREParserBackslash, 0)
}

func (s *Backreference_or_octalContext) Digit() IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Backreference_or_octalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backreference_or_octalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Backreference_or_octalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBackreference_or_octal(s)
	}
}

func (s *Backreference_or_octalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBackreference_or_octal(s)
	}
}

func (s *Backreference_or_octalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitBackreference_or_octal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Backreference_or_octal() (localctx IBackreference_or_octalContext) {
	localctx = NewBackreference_or_octalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PCREParserRULE_backreference_or_octal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(251)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(248)
			p.Octal_char()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(249)
			p.Match(PCREParserBackslash)
		}
		{
			p.SetState(250)
			p.Digit()
		}

	}

	return localctx
}

// ICaptureContext is an interface to support dynamic dispatch.
type ICaptureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaptureContext differentiates from other interfaces.
	IsCaptureContext()
}

type CaptureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaptureContext() *CaptureContext {
	var p = new(CaptureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_capture
	return p
}

func (*CaptureContext) IsCaptureContext() {}

func NewCaptureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaptureContext {
	var p = new(CaptureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_capture

	return p
}

func (s *CaptureContext) GetParser() antlr.Parser { return s.parser }

func (s *CaptureContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *CaptureContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *CaptureContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *CaptureContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *CaptureContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *CaptureContext) Alternation() IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *CaptureContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *CaptureContext) AllSingleQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSingleQuote)
}

func (s *CaptureContext) SingleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, i)
}

func (s *CaptureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaptureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaptureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCapture(s)
	}
}

func (s *CaptureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCapture(s)
	}
}

func (s *CaptureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCapture(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Capture() (localctx ICaptureContext) {
	localctx = NewCaptureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PCREParserRULE_capture)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(253)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(254)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(255)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(256)
			p.Name()
		}
		{
			p.SetState(257)
			p.Match(PCREParserGreaterThan)
		}
		{
			p.SetState(258)
			p.Alternation()
		}
		{
			p.SetState(259)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(261)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(262)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(263)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(264)
			p.Name()
		}
		{
			p.SetState(265)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(266)
			p.Alternation()
		}
		{
			p.SetState(267)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(269)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(270)
			p.Alternation()
		}
		{
			p.SetState(271)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// INon_captureContext is an interface to support dynamic dispatch.
type INon_captureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_captureContext differentiates from other interfaces.
	IsNon_captureContext()
}

type Non_captureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_captureContext() *Non_captureContext {
	var p = new(Non_captureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_non_capture
	return p
}

func (*Non_captureContext) IsNon_captureContext() {}

func NewNon_captureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_captureContext {
	var p = new(Non_captureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_non_capture

	return p
}

func (s *Non_captureContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_captureContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Non_captureContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Non_captureContext) Colon() antlr.TerminalNode {
	return s.GetToken(PCREParserColon, 0)
}

func (s *Non_captureContext) Alternation() IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *Non_captureContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Non_captureContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, 0)
}

func (s *Non_captureContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *Non_captureContext) Option_flags() IOption_flagsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOption_flagsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOption_flagsContext)
}

func (s *Non_captureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_captureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_captureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNon_capture(s)
	}
}

func (s *Non_captureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNon_capture(s)
	}
}

func (s *Non_captureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitNon_capture(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Non_capture() (localctx INon_captureContext) {
	localctx = NewNon_captureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PCREParserRULE_non_capture)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(275)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(276)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(277)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(278)
			p.Alternation()
		}
		{
			p.SetState(279)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(281)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(282)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(283)
			p.Match(PCREParserPipe)
		}
		{
			p.SetState(284)
			p.Alternation()
		}
		{
			p.SetState(285)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(287)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(288)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(289)
			p.Match(PCREParserGreaterThan)
		}
		{
			p.SetState(290)
			p.Alternation()
		}
		{
			p.SetState(291)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(293)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(294)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(295)
			p.Option_flags()
		}
		{
			p.SetState(296)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(297)
			p.Alternation()
		}
		{
			p.SetState(298)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_comment
	return p
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *CommentContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *CommentContext) Hash() antlr.TerminalNode {
	return s.GetToken(PCREParserHash, 0)
}

func (s *CommentContext) Non_close_parens() INon_close_parensContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_close_parensContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_close_parensContext)
}

func (s *CommentContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitComment(s)
	}
}

func (s *CommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PCREParserRULE_comment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		p.Match(PCREParserOpenParen)
	}
	{
		p.SetState(303)
		p.Match(PCREParserQuestionMark)
	}
	{
		p.SetState(304)
		p.Match(PCREParserHash)
	}
	{
		p.SetState(305)
		p.Non_close_parens()
	}
	{
		p.SetState(306)
		p.Match(PCREParserCloseParen)
	}

	return localctx
}

// IOptionContext is an interface to support dynamic dispatch.
type IOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionContext differentiates from other interfaces.
	IsOptionContext()
}

type OptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionContext() *OptionContext {
	var p = new(OptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_option
	return p
}

func (*OptionContext) IsOptionContext() {}

func NewOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionContext {
	var p = new(OptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_option

	return p
}

func (s *OptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *OptionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *OptionContext) AllOption_flags() []IOption_flagsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOption_flagsContext)(nil)).Elem())
	var tst = make([]IOption_flagsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOption_flagsContext)
		}
	}

	return tst
}

func (s *OptionContext) Option_flags(i int) IOption_flagsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOption_flagsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOption_flagsContext)
}

func (s *OptionContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *OptionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *OptionContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *OptionContext) NUC() antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, 0)
}

func (s *OptionContext) AllOUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserOUC)
}

func (s *OptionContext) OUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserOUC, i)
}

func (s *OptionContext) AllUnderscore() []antlr.TerminalNode {
	return s.GetTokens(PCREParserUnderscore)
}

func (s *OptionContext) Underscore(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserUnderscore, i)
}

func (s *OptionContext) SUC() antlr.TerminalNode {
	return s.GetToken(PCREParserSUC, 0)
}

func (s *OptionContext) AllTUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserTUC)
}

func (s *OptionContext) TUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserTUC, i)
}

func (s *OptionContext) AUC() antlr.TerminalNode {
	return s.GetToken(PCREParserAUC, 0)
}

func (s *OptionContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *OptionContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *OptionContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *OptionContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *OptionContext) D8() antlr.TerminalNode {
	return s.GetToken(PCREParserD8, 0)
}

func (s *OptionContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *OptionContext) D6() antlr.TerminalNode {
	return s.GetToken(PCREParserD6, 0)
}

func (s *OptionContext) CUC() antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, 0)
}

func (s *OptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOption(s)
	}
}

func (s *OptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOption(s)
	}
}

func (s *OptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Option() (localctx IOptionContext) {
	localctx = NewOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, PCREParserRULE_option)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(362)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(308)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(309)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(310)
			p.Option_flags()
		}
		{
			p.SetState(311)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(312)
			p.Option_flags()
		}
		{
			p.SetState(313)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(315)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(316)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(317)
			p.Option_flags()
		}
		{
			p.SetState(318)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(320)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(321)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(322)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(323)
			p.Option_flags()
		}
		{
			p.SetState(324)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(326)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(327)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(328)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(329)
			p.Match(PCREParserOUC)
		}
		{
			p.SetState(330)
			p.Match(PCREParserUnderscore)
		}
		{
			p.SetState(331)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(332)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(333)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(334)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(335)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(336)
			p.Match(PCREParserUnderscore)
		}
		{
			p.SetState(337)
			p.Match(PCREParserOUC)
		}
		{
			p.SetState(338)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(339)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(340)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(341)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(342)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(343)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(344)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(345)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(346)
			p.Match(PCREParserD8)
		}
		{
			p.SetState(347)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(348)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(349)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(350)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(351)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(352)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(353)
			p.Match(PCREParserD1)
		}
		{
			p.SetState(354)
			p.Match(PCREParserD6)
		}
		{
			p.SetState(355)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(356)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(357)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(358)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(359)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(360)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(361)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// IOption_flagsContext is an interface to support dynamic dispatch.
type IOption_flagsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOption_flagsContext differentiates from other interfaces.
	IsOption_flagsContext()
}

type Option_flagsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOption_flagsContext() *Option_flagsContext {
	var p = new(Option_flagsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_option_flags
	return p
}

func (*Option_flagsContext) IsOption_flagsContext() {}

func NewOption_flagsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Option_flagsContext {
	var p = new(Option_flagsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_option_flags

	return p
}

func (s *Option_flagsContext) GetParser() antlr.Parser { return s.parser }

func (s *Option_flagsContext) AllOption_flag() []IOption_flagContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOption_flagContext)(nil)).Elem())
	var tst = make([]IOption_flagContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOption_flagContext)
		}
	}

	return tst
}

func (s *Option_flagsContext) Option_flag(i int) IOption_flagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOption_flagContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOption_flagContext)
}

func (s *Option_flagsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Option_flagsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Option_flagsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOption_flags(s)
	}
}

func (s *Option_flagsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOption_flags(s)
	}
}

func (s *Option_flagsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitOption_flags(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Option_flags() (localctx IOption_flagsContext) {
	localctx = NewOption_flagsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PCREParserRULE_option_flags)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(PCREParserILC-74))|(1<<(PCREParserMLC-74))|(1<<(PCREParserSLC-74))|(1<<(PCREParserXLC-74))|(1<<(PCREParserJUC-74)))) != 0) || _la == PCREParserUUC {
		{
			p.SetState(364)
			p.Option_flag()
		}

		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOption_flagContext is an interface to support dynamic dispatch.
type IOption_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOption_flagContext differentiates from other interfaces.
	IsOption_flagContext()
}

type Option_flagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOption_flagContext() *Option_flagContext {
	var p = new(Option_flagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_option_flag
	return p
}

func (*Option_flagContext) IsOption_flagContext() {}

func NewOption_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Option_flagContext {
	var p = new(Option_flagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_option_flag

	return p
}

func (s *Option_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Option_flagContext) ILC() antlr.TerminalNode {
	return s.GetToken(PCREParserILC, 0)
}

func (s *Option_flagContext) JUC() antlr.TerminalNode {
	return s.GetToken(PCREParserJUC, 0)
}

func (s *Option_flagContext) MLC() antlr.TerminalNode {
	return s.GetToken(PCREParserMLC, 0)
}

func (s *Option_flagContext) SLC() antlr.TerminalNode {
	return s.GetToken(PCREParserSLC, 0)
}

func (s *Option_flagContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *Option_flagContext) XLC() antlr.TerminalNode {
	return s.GetToken(PCREParserXLC, 0)
}

func (s *Option_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Option_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Option_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOption_flag(s)
	}
}

func (s *Option_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOption_flag(s)
	}
}

func (s *Option_flagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitOption_flag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Option_flag() (localctx IOption_flagContext) {
	localctx = NewOption_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, PCREParserRULE_option_flag)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(PCREParserILC-74))|(1<<(PCREParserMLC-74))|(1<<(PCREParserSLC-74))|(1<<(PCREParserXLC-74))|(1<<(PCREParserJUC-74)))) != 0) || _la == PCREParserUUC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILook_aroundContext is an interface to support dynamic dispatch.
type ILook_aroundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLook_aroundContext differentiates from other interfaces.
	IsLook_aroundContext()
}

type Look_aroundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLook_aroundContext() *Look_aroundContext {
	var p = new(Look_aroundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_look_around
	return p
}

func (*Look_aroundContext) IsLook_aroundContext() {}

func NewLook_aroundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Look_aroundContext {
	var p = new(Look_aroundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_look_around

	return p
}

func (s *Look_aroundContext) GetParser() antlr.Parser { return s.parser }

func (s *Look_aroundContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Look_aroundContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Look_aroundContext) Equals() antlr.TerminalNode {
	return s.GetToken(PCREParserEquals, 0)
}

func (s *Look_aroundContext) Alternation() IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *Look_aroundContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Look_aroundContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(PCREParserExclamation, 0)
}

func (s *Look_aroundContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *Look_aroundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Look_aroundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Look_aroundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLook_around(s)
	}
}

func (s *Look_aroundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLook_around(s)
	}
}

func (s *Look_aroundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitLook_around(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Look_around() (localctx ILook_aroundContext) {
	localctx = NewLook_aroundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PCREParserRULE_look_around)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(371)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(372)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(373)
			p.Match(PCREParserEquals)
		}
		{
			p.SetState(374)
			p.Alternation()
		}
		{
			p.SetState(375)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(377)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(378)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(379)
			p.Match(PCREParserExclamation)
		}
		{
			p.SetState(380)
			p.Alternation()
		}
		{
			p.SetState(381)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(383)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(384)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(385)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(386)
			p.Match(PCREParserEquals)
		}
		{
			p.SetState(387)
			p.Alternation()
		}
		{
			p.SetState(388)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(390)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(391)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(392)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(393)
			p.Match(PCREParserExclamation)
		}
		{
			p.SetState(394)
			p.Alternation()
		}
		{
			p.SetState(395)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// ISubroutine_referenceContext is an interface to support dynamic dispatch.
type ISubroutine_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubroutine_referenceContext differentiates from other interfaces.
	IsSubroutine_referenceContext()
}

type Subroutine_referenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubroutine_referenceContext() *Subroutine_referenceContext {
	var p = new(Subroutine_referenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_subroutine_reference
	return p
}

func (*Subroutine_referenceContext) IsSubroutine_referenceContext() {}

func NewSubroutine_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subroutine_referenceContext {
	var p = new(Subroutine_referenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_subroutine_reference

	return p
}

func (s *Subroutine_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Subroutine_referenceContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Subroutine_referenceContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Subroutine_referenceContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *Subroutine_referenceContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Subroutine_referenceContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Subroutine_referenceContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *Subroutine_referenceContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *Subroutine_referenceContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PCREParserAmpersand, 0)
}

func (s *Subroutine_referenceContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Subroutine_referenceContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *Subroutine_referenceContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *Subroutine_referenceContext) SubroutineOrNamedReferenceStartG() antlr.TerminalNode {
	return s.GetToken(PCREParserSubroutineOrNamedReferenceStartG, 0)
}

func (s *Subroutine_referenceContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *Subroutine_referenceContext) AllSingleQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSingleQuote)
}

func (s *Subroutine_referenceContext) SingleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, i)
}

func (s *Subroutine_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subroutine_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subroutine_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterSubroutine_reference(s)
	}
}

func (s *Subroutine_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitSubroutine_reference(s)
	}
}

func (s *Subroutine_referenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitSubroutine_reference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Subroutine_reference() (localctx ISubroutine_referenceContext) {
	localctx = NewSubroutine_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, PCREParserRULE_subroutine_reference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(399)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(400)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(401)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(402)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(403)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(404)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(405)
			p.Number()
		}
		{
			p.SetState(406)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(408)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(409)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(410)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(411)
			p.Number()
		}
		{
			p.SetState(412)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(414)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(415)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(416)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(417)
			p.Number()
		}
		{
			p.SetState(418)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(420)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(421)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(422)
			p.Match(PCREParserAmpersand)
		}
		{
			p.SetState(423)
			p.Name()
		}
		{
			p.SetState(424)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(426)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(427)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(428)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(429)
			p.Match(PCREParserGreaterThan)
		}
		{
			p.SetState(430)
			p.Name()
		}
		{
			p.SetState(431)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(433)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(434)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(435)
			p.Name()
		}
		{
			p.SetState(436)
			p.Match(PCREParserGreaterThan)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(438)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(439)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(440)
			p.Name()
		}
		{
			p.SetState(441)
			p.Match(PCREParserSingleQuote)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(443)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(444)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(445)
			p.Number()
		}
		{
			p.SetState(446)
			p.Match(PCREParserGreaterThan)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(448)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(449)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(450)
			p.Number()
		}
		{
			p.SetState(451)
			p.Match(PCREParserSingleQuote)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(453)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(454)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(455)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(456)
			p.Number()
		}
		{
			p.SetState(457)
			p.Match(PCREParserGreaterThan)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(459)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(460)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(461)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(462)
			p.Number()
		}
		{
			p.SetState(463)
			p.Match(PCREParserSingleQuote)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(465)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(466)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(467)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(468)
			p.Number()
		}
		{
			p.SetState(469)
			p.Match(PCREParserGreaterThan)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(471)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(472)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(473)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(474)
			p.Number()
		}
		{
			p.SetState(475)
			p.Match(PCREParserSingleQuote)
		}

	}

	return localctx
}

// IConditionalContext is an interface to support dynamic dispatch.
type IConditionalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalContext differentiates from other interfaces.
	IsConditionalContext()
}

type ConditionalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalContext() *ConditionalContext {
	var p = new(ConditionalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_conditional
	return p
}

func (*ConditionalContext) IsConditionalContext() {}

func NewConditionalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalContext {
	var p = new(ConditionalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_conditional

	return p
}

func (s *ConditionalContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalContext) AllOpenParen() []antlr.TerminalNode {
	return s.GetTokens(PCREParserOpenParen)
}

func (s *ConditionalContext) OpenParen(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, i)
}

func (s *ConditionalContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *ConditionalContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *ConditionalContext) AllCloseParen() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCloseParen)
}

func (s *ConditionalContext) CloseParen(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, i)
}

func (s *ConditionalContext) AllAlternation() []IAlternationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlternationContext)(nil)).Elem())
	var tst = make([]IAlternationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlternationContext)
		}
	}

	return tst
}

func (s *ConditionalContext) Alternation(i int) IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *ConditionalContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, 0)
}

func (s *ConditionalContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *ConditionalContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *ConditionalContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *ConditionalContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ConditionalContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *ConditionalContext) AllSingleQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSingleQuote)
}

func (s *ConditionalContext) SingleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, i)
}

func (s *ConditionalContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *ConditionalContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PCREParserAmpersand, 0)
}

func (s *ConditionalContext) DUC() antlr.TerminalNode {
	return s.GetToken(PCREParserDUC, 0)
}

func (s *ConditionalContext) AllEUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserEUC)
}

func (s *ConditionalContext) EUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserEUC, i)
}

func (s *ConditionalContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *ConditionalContext) IUC() antlr.TerminalNode {
	return s.GetToken(PCREParserIUC, 0)
}

func (s *ConditionalContext) NUC() antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, 0)
}

func (s *ConditionalContext) ALC() antlr.TerminalNode {
	return s.GetToken(PCREParserALC, 0)
}

func (s *ConditionalContext) AllSLC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSLC)
}

func (s *ConditionalContext) SLC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSLC, i)
}

func (s *ConditionalContext) ELC() antlr.TerminalNode {
	return s.GetToken(PCREParserELC, 0)
}

func (s *ConditionalContext) RLC() antlr.TerminalNode {
	return s.GetToken(PCREParserRLC, 0)
}

func (s *ConditionalContext) TLC() antlr.TerminalNode {
	return s.GetToken(PCREParserTLC, 0)
}

func (s *ConditionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterConditional(s)
	}
}

func (s *ConditionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitConditional(s)
	}
}

func (s *ConditionalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitConditional(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Conditional() (localctx IConditionalContext) {
	localctx = NewConditionalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, PCREParserRULE_conditional)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(479)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(480)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(481)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(482)
			p.Number()
		}
		{
			p.SetState(483)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(484)
			p.Alternation()
		}
		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(485)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(486)
				p.Alternation()
			}

		}
		{
			p.SetState(489)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(491)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(492)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(493)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(494)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(495)
			p.Number()
		}
		{
			p.SetState(496)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(497)
			p.Alternation()
		}
		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(498)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(499)
				p.Alternation()
			}

		}
		{
			p.SetState(502)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(504)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(505)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(506)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(507)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(508)
			p.Number()
		}
		{
			p.SetState(509)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(510)
			p.Alternation()
		}
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(511)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(512)
				p.Alternation()
			}

		}
		{
			p.SetState(515)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(517)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(518)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(519)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(520)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(521)
			p.Name()
		}
		{
			p.SetState(522)
			p.Match(PCREParserGreaterThan)
		}
		{
			p.SetState(523)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(524)
			p.Alternation()
		}
		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(525)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(526)
				p.Alternation()
			}

		}
		{
			p.SetState(529)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(531)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(532)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(533)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(534)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(535)
			p.Name()
		}
		{
			p.SetState(536)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(537)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(538)
			p.Alternation()
		}
		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(539)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(540)
				p.Alternation()
			}

		}
		{
			p.SetState(543)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(545)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(546)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(547)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(548)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(549)
			p.Number()
		}
		{
			p.SetState(550)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(551)
			p.Alternation()
		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(552)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(553)
				p.Alternation()
			}

		}
		{
			p.SetState(556)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(558)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(559)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(560)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(561)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(562)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(563)
			p.Alternation()
		}
		p.SetState(566)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(564)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(565)
				p.Alternation()
			}

		}
		{
			p.SetState(568)
			p.Match(PCREParserCloseParen)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(570)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(571)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(572)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(573)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(574)
			p.Match(PCREParserAmpersand)
		}
		{
			p.SetState(575)
			p.Name()
		}
		{
			p.SetState(576)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(577)
			p.Alternation()
		}
		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(578)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(579)
				p.Alternation()
			}

		}
		{
			p.SetState(582)
			p.Match(PCREParserCloseParen)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(584)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(585)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(586)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(587)
			p.Match(PCREParserDUC)
		}
		{
			p.SetState(588)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(589)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(590)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(591)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(592)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(593)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(594)
			p.Alternation()
		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(595)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(596)
				p.Alternation()
			}

		}
		{
			p.SetState(599)
			p.Match(PCREParserCloseParen)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(601)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(602)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(603)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(604)
			p.Match(PCREParserALC)
		}
		{
			p.SetState(605)
			p.Match(PCREParserSLC)
		}
		{
			p.SetState(606)
			p.Match(PCREParserSLC)
		}
		{
			p.SetState(607)
			p.Match(PCREParserELC)
		}
		{
			p.SetState(608)
			p.Match(PCREParserRLC)
		}
		{
			p.SetState(609)
			p.Match(PCREParserTLC)
		}
		{
			p.SetState(610)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(611)
			p.Alternation()
		}
		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(612)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(613)
				p.Alternation()
			}

		}
		{
			p.SetState(616)
			p.Match(PCREParserCloseParen)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(618)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(619)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(620)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(621)
			p.Name()
		}
		{
			p.SetState(622)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(623)
			p.Alternation()
		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(624)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(625)
				p.Alternation()
			}

		}
		{
			p.SetState(628)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// IBacktrack_controlContext is an interface to support dynamic dispatch.
type IBacktrack_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBacktrack_controlContext differentiates from other interfaces.
	IsBacktrack_controlContext()
}

type Backtrack_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBacktrack_controlContext() *Backtrack_controlContext {
	var p = new(Backtrack_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_backtrack_control
	return p
}

func (*Backtrack_controlContext) IsBacktrack_controlContext() {}

func NewBacktrack_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backtrack_controlContext {
	var p = new(Backtrack_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_backtrack_control

	return p
}

func (s *Backtrack_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Backtrack_controlContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Backtrack_controlContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *Backtrack_controlContext) AllAUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserAUC)
}

func (s *Backtrack_controlContext) AUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserAUC, i)
}

func (s *Backtrack_controlContext) AllCUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCUC)
}

func (s *Backtrack_controlContext) CUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, i)
}

func (s *Backtrack_controlContext) AllEUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserEUC)
}

func (s *Backtrack_controlContext) EUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserEUC, i)
}

func (s *Backtrack_controlContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *Backtrack_controlContext) TUC() antlr.TerminalNode {
	return s.GetToken(PCREParserTUC, 0)
}

func (s *Backtrack_controlContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Backtrack_controlContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *Backtrack_controlContext) IUC() antlr.TerminalNode {
	return s.GetToken(PCREParserIUC, 0)
}

func (s *Backtrack_controlContext) LUC() antlr.TerminalNode {
	return s.GetToken(PCREParserLUC, 0)
}

func (s *Backtrack_controlContext) Colon() antlr.TerminalNode {
	return s.GetToken(PCREParserColon, 0)
}

func (s *Backtrack_controlContext) AllNUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserNUC)
}

func (s *Backtrack_controlContext) NUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, i)
}

func (s *Backtrack_controlContext) AllMUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserMUC)
}

func (s *Backtrack_controlContext) MUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserMUC, i)
}

func (s *Backtrack_controlContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *Backtrack_controlContext) KUC() antlr.TerminalNode {
	return s.GetToken(PCREParserKUC, 0)
}

func (s *Backtrack_controlContext) OUC() antlr.TerminalNode {
	return s.GetToken(PCREParserOUC, 0)
}

func (s *Backtrack_controlContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *Backtrack_controlContext) SUC() antlr.TerminalNode {
	return s.GetToken(PCREParserSUC, 0)
}

func (s *Backtrack_controlContext) HUC() antlr.TerminalNode {
	return s.GetToken(PCREParserHUC, 0)
}

func (s *Backtrack_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backtrack_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Backtrack_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBacktrack_control(s)
	}
}

func (s *Backtrack_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBacktrack_control(s)
	}
}

func (s *Backtrack_controlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitBacktrack_control(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Backtrack_control() (localctx IBacktrack_controlContext) {
	localctx = NewBacktrack_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, PCREParserRULE_backtrack_control)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(632)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(633)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(634)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(635)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(636)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(637)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(638)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(639)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(640)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(641)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(642)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(643)
			p.Match(PCREParserFUC)
		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserAUC {
			{
				p.SetState(644)
				p.Match(PCREParserAUC)
			}
			{
				p.SetState(645)
				p.Match(PCREParserIUC)
			}
			{
				p.SetState(646)
				p.Match(PCREParserLUC)
			}

		}
		{
			p.SetState(649)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(650)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(651)
			p.Match(PCREParserStar)
		}
		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserMUC {
			{
				p.SetState(652)
				p.Match(PCREParserMUC)
			}
			{
				p.SetState(653)
				p.Match(PCREParserAUC)
			}
			{
				p.SetState(654)
				p.Match(PCREParserRUC)
			}
			{
				p.SetState(655)
				p.Match(PCREParserKUC)
			}

		}
		{
			p.SetState(658)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(659)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(660)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(661)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(662)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(663)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(664)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(665)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(666)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(667)
			p.Match(PCREParserOUC)
		}
		{
			p.SetState(668)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(669)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(670)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(671)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(672)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(673)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(674)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(675)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(676)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(677)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(678)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(679)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(680)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(681)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(682)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(683)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(684)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(685)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(686)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(687)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(688)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(689)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(690)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(691)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(692)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(693)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(694)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(695)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(696)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(697)
			p.Match(PCREParserKUC)
		}
		{
			p.SetState(698)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(699)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(700)
			p.Match(PCREParserCloseParen)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(701)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(702)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(703)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(704)
			p.Match(PCREParserKUC)
		}
		{
			p.SetState(705)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(706)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(707)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(708)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(709)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(710)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(711)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(712)
			p.Match(PCREParserCloseParen)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(713)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(714)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(715)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(716)
			p.Match(PCREParserHUC)
		}
		{
			p.SetState(717)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(718)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(719)
			p.Match(PCREParserCloseParen)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(720)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(721)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(722)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(723)
			p.Match(PCREParserHUC)
		}
		{
			p.SetState(724)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(725)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(726)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(727)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(728)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(729)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(730)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(731)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// INewline_conventionContext is an interface to support dynamic dispatch.
type INewline_conventionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNewline_conventionContext differentiates from other interfaces.
	IsNewline_conventionContext()
}

type Newline_conventionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewline_conventionContext() *Newline_conventionContext {
	var p = new(Newline_conventionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_newline_convention
	return p
}

func (*Newline_conventionContext) IsNewline_conventionContext() {}

func NewNewline_conventionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Newline_conventionContext {
	var p = new(Newline_conventionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_newline_convention

	return p
}

func (s *Newline_conventionContext) GetParser() antlr.Parser { return s.parser }

func (s *Newline_conventionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Newline_conventionContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *Newline_conventionContext) CUC() antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, 0)
}

func (s *Newline_conventionContext) AllRUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserRUC)
}

func (s *Newline_conventionContext) RUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, i)
}

func (s *Newline_conventionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Newline_conventionContext) LUC() antlr.TerminalNode {
	return s.GetToken(PCREParserLUC, 0)
}

func (s *Newline_conventionContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *Newline_conventionContext) AUC() antlr.TerminalNode {
	return s.GetToken(PCREParserAUC, 0)
}

func (s *Newline_conventionContext) NUC() antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, 0)
}

func (s *Newline_conventionContext) YUC() antlr.TerminalNode {
	return s.GetToken(PCREParserYUC, 0)
}

func (s *Newline_conventionContext) BUC() antlr.TerminalNode {
	return s.GetToken(PCREParserBUC, 0)
}

func (s *Newline_conventionContext) SUC() antlr.TerminalNode {
	return s.GetToken(PCREParserSUC, 0)
}

func (s *Newline_conventionContext) Underscore() antlr.TerminalNode {
	return s.GetToken(PCREParserUnderscore, 0)
}

func (s *Newline_conventionContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *Newline_conventionContext) IUC() antlr.TerminalNode {
	return s.GetToken(PCREParserIUC, 0)
}

func (s *Newline_conventionContext) OUC() antlr.TerminalNode {
	return s.GetToken(PCREParserOUC, 0)
}

func (s *Newline_conventionContext) DUC() antlr.TerminalNode {
	return s.GetToken(PCREParserDUC, 0)
}

func (s *Newline_conventionContext) EUC() antlr.TerminalNode {
	return s.GetToken(PCREParserEUC, 0)
}

func (s *Newline_conventionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Newline_conventionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Newline_conventionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNewline_convention(s)
	}
}

func (s *Newline_conventionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNewline_convention(s)
	}
}

func (s *Newline_conventionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitNewline_convention(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Newline_convention() (localctx INewline_conventionContext) {
	localctx = NewNewline_conventionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, PCREParserRULE_newline_convention)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(734)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(735)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(736)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(737)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(738)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(740)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(741)
			p.Match(PCREParserLUC)
		}
		{
			p.SetState(742)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(743)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(744)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(745)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(746)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(747)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(748)
			p.Match(PCREParserLUC)
		}
		{
			p.SetState(749)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(750)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(751)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(752)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(753)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(754)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(755)
			p.Match(PCREParserYUC)
		}
		{
			p.SetState(756)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(757)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(758)
			p.Match(PCREParserLUC)
		}
		{
			p.SetState(759)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(760)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(761)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(762)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(763)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(764)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(765)
			p.Match(PCREParserYUC)
		}
		{
			p.SetState(766)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(767)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(768)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(769)
			p.Match(PCREParserBUC)
		}
		{
			p.SetState(770)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(771)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(772)
			p.Match(PCREParserUnderscore)
		}
		{
			p.SetState(773)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(774)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(775)
			p.Match(PCREParserYUC)
		}
		{
			p.SetState(776)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(777)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(778)
			p.Match(PCREParserLUC)
		}
		{
			p.SetState(779)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(780)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(781)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(782)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(783)
			p.Match(PCREParserBUC)
		}
		{
			p.SetState(784)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(785)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(786)
			p.Match(PCREParserUnderscore)
		}
		{
			p.SetState(787)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(788)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(789)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(790)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(791)
			p.Match(PCREParserOUC)
		}
		{
			p.SetState(792)
			p.Match(PCREParserDUC)
		}
		{
			p.SetState(793)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(794)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// ICalloutContext is an interface to support dynamic dispatch.
type ICalloutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCalloutContext differentiates from other interfaces.
	IsCalloutContext()
}

type CalloutContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalloutContext() *CalloutContext {
	var p = new(CalloutContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_callout
	return p
}

func (*CalloutContext) IsCalloutContext() {}

func NewCalloutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalloutContext {
	var p = new(CalloutContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_callout

	return p
}

func (s *CalloutContext) GetParser() antlr.Parser { return s.parser }

func (s *CalloutContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *CalloutContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *CalloutContext) CUC() antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, 0)
}

func (s *CalloutContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *CalloutContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *CalloutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalloutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalloutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCallout(s)
	}
}

func (s *CalloutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCallout(s)
	}
}

func (s *CalloutContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCallout(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Callout() (localctx ICalloutContext) {
	localctx = NewCalloutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, PCREParserRULE_callout)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(797)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(798)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(799)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(800)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(801)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(802)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(803)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(804)
			p.Number()
		}
		{
			p.SetState(805)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Subroutine_reference() ISubroutine_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_referenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_referenceContext)
}

func (s *AtomContext) Shared_atom() IShared_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShared_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShared_atomContext)
}

func (s *AtomContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomContext) Character_class() ICharacter_classContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacter_classContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacter_classContext)
}

func (s *AtomContext) Capture() ICaptureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaptureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaptureContext)
}

func (s *AtomContext) Non_capture() INon_captureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_captureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_captureContext)
}

func (s *AtomContext) Comment() ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *AtomContext) Option() IOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionContext)
}

func (s *AtomContext) Look_around() ILook_aroundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILook_aroundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILook_aroundContext)
}

func (s *AtomContext) Backreference() IBackreferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackreferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackreferenceContext)
}

func (s *AtomContext) Conditional() IConditionalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalContext)
}

func (s *AtomContext) Backtrack_control() IBacktrack_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBacktrack_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBacktrack_controlContext)
}

func (s *AtomContext) Newline_convention() INewline_conventionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewline_conventionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewline_conventionContext)
}

func (s *AtomContext) Callout() ICalloutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICalloutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICalloutContext)
}

func (s *AtomContext) Dot() antlr.TerminalNode {
	return s.GetToken(PCREParserDot, 0)
}

func (s *AtomContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *AtomContext) StartOfSubject() antlr.TerminalNode {
	return s.GetToken(PCREParserStartOfSubject, 0)
}

func (s *AtomContext) WordBoundary() antlr.TerminalNode {
	return s.GetToken(PCREParserWordBoundary, 0)
}

func (s *AtomContext) NonWordBoundary() antlr.TerminalNode {
	return s.GetToken(PCREParserNonWordBoundary, 0)
}

func (s *AtomContext) EndOfSubjectOrLine() antlr.TerminalNode {
	return s.GetToken(PCREParserEndOfSubjectOrLine, 0)
}

func (s *AtomContext) EndOfSubjectOrLineEndOfSubject() antlr.TerminalNode {
	return s.GetToken(PCREParserEndOfSubjectOrLineEndOfSubject, 0)
}

func (s *AtomContext) EndOfSubject() antlr.TerminalNode {
	return s.GetToken(PCREParserEndOfSubject, 0)
}

func (s *AtomContext) PreviousMatchInSubject() antlr.TerminalNode {
	return s.GetToken(PCREParserPreviousMatchInSubject, 0)
}

func (s *AtomContext) ResetStartMatch() antlr.TerminalNode {
	return s.GetToken(PCREParserResetStartMatch, 0)
}

func (s *AtomContext) OneDataUnit() antlr.TerminalNode {
	return s.GetToken(PCREParserOneDataUnit, 0)
}

func (s *AtomContext) ExtendedUnicodeChar() antlr.TerminalNode {
	return s.GetToken(PCREParserExtendedUnicodeChar, 0)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (s *AtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PCREParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(809)
			p.Subroutine_reference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(810)
			p.Shared_atom()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(811)
			p.Literal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(812)
			p.Character_class()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(813)
			p.Capture()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(814)
			p.Non_capture()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(815)
			p.Comment()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(816)
			p.Option()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(817)
			p.Look_around()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(818)
			p.Backreference()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(819)
			p.Conditional()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(820)
			p.Backtrack_control()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(821)
			p.Newline_convention()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(822)
			p.Callout()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(823)
			p.Match(PCREParserDot)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(824)
			p.Match(PCREParserCaret)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(825)
			p.Match(PCREParserStartOfSubject)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(826)
			p.Match(PCREParserWordBoundary)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(827)
			p.Match(PCREParserNonWordBoundary)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(828)
			p.Match(PCREParserEndOfSubjectOrLine)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(829)
			p.Match(PCREParserEndOfSubjectOrLineEndOfSubject)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(830)
			p.Match(PCREParserEndOfSubject)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(831)
			p.Match(PCREParserPreviousMatchInSubject)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(832)
			p.Match(PCREParserResetStartMatch)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(833)
			p.Match(PCREParserOneDataUnit)
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(834)
			p.Match(PCREParserExtendedUnicodeChar)
		}

	}

	return localctx
}

// ICc_atomContext is an interface to support dynamic dispatch.
type ICc_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCc_atomContext differentiates from other interfaces.
	IsCc_atomContext()
}

type Cc_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCc_atomContext() *Cc_atomContext {
	var p = new(Cc_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_cc_atom
	return p
}

func (*Cc_atomContext) IsCc_atomContext() {}

func NewCc_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cc_atomContext {
	var p = new(Cc_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_cc_atom

	return p
}

func (s *Cc_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Cc_atomContext) AllCc_literal() []ICc_literalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICc_literalContext)(nil)).Elem())
	var tst = make([]ICc_literalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICc_literalContext)
		}
	}

	return tst
}

func (s *Cc_atomContext) Cc_literal(i int) ICc_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICc_literalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICc_literalContext)
}

func (s *Cc_atomContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *Cc_atomContext) Shared_atom() IShared_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShared_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShared_atomContext)
}

func (s *Cc_atomContext) Backreference_or_octal() IBackreference_or_octalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackreference_or_octalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackreference_or_octalContext)
}

func (s *Cc_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cc_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cc_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCc_atom(s)
	}
}

func (s *Cc_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCc_atom(s)
	}
}

func (s *Cc_atomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCc_atom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Cc_atom() (localctx ICc_atomContext) {
	localctx = NewCc_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PCREParserRULE_cc_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(837)
			p.Cc_literal()
		}
		{
			p.SetState(838)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(839)
			p.Cc_literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(841)
			p.Shared_atom()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(842)
			p.Cc_literal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(843)
			p.Backreference_or_octal()
		}

	}

	return localctx
}

// IShared_atomContext is an interface to support dynamic dispatch.
type IShared_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShared_atomContext differentiates from other interfaces.
	IsShared_atomContext()
}

type Shared_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShared_atomContext() *Shared_atomContext {
	var p = new(Shared_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_shared_atom
	return p
}

func (*Shared_atomContext) IsShared_atomContext() {}

func NewShared_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shared_atomContext {
	var p = new(Shared_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_shared_atom

	return p
}

func (s *Shared_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Shared_atomContext) POSIXNamedSet() antlr.TerminalNode {
	return s.GetToken(PCREParserPOSIXNamedSet, 0)
}

func (s *Shared_atomContext) POSIXNegatedNamedSet() antlr.TerminalNode {
	return s.GetToken(PCREParserPOSIXNegatedNamedSet, 0)
}

func (s *Shared_atomContext) ControlChar() antlr.TerminalNode {
	return s.GetToken(PCREParserControlChar, 0)
}

func (s *Shared_atomContext) DecimalDigit() antlr.TerminalNode {
	return s.GetToken(PCREParserDecimalDigit, 0)
}

func (s *Shared_atomContext) NotDecimalDigit() antlr.TerminalNode {
	return s.GetToken(PCREParserNotDecimalDigit, 0)
}

func (s *Shared_atomContext) HorizontalWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserHorizontalWhiteSpace, 0)
}

func (s *Shared_atomContext) NotHorizontalWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserNotHorizontalWhiteSpace, 0)
}

func (s *Shared_atomContext) NotNewLine() antlr.TerminalNode {
	return s.GetToken(PCREParserNotNewLine, 0)
}

func (s *Shared_atomContext) CharWithProperty() antlr.TerminalNode {
	return s.GetToken(PCREParserCharWithProperty, 0)
}

func (s *Shared_atomContext) CharWithoutProperty() antlr.TerminalNode {
	return s.GetToken(PCREParserCharWithoutProperty, 0)
}

func (s *Shared_atomContext) NewLineSequence() antlr.TerminalNode {
	return s.GetToken(PCREParserNewLineSequence, 0)
}

func (s *Shared_atomContext) WhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserWhiteSpace, 0)
}

func (s *Shared_atomContext) NotWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserNotWhiteSpace, 0)
}

func (s *Shared_atomContext) VerticalWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserVerticalWhiteSpace, 0)
}

func (s *Shared_atomContext) NotVerticalWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserNotVerticalWhiteSpace, 0)
}

func (s *Shared_atomContext) WordChar() antlr.TerminalNode {
	return s.GetToken(PCREParserWordChar, 0)
}

func (s *Shared_atomContext) NotWordChar() antlr.TerminalNode {
	return s.GetToken(PCREParserNotWordChar, 0)
}

func (s *Shared_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shared_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shared_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterShared_atom(s)
	}
}

func (s *Shared_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitShared_atom(s)
	}
}

func (s *Shared_atomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitShared_atom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Shared_atom() (localctx IShared_atomContext) {
	localctx = NewShared_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PCREParserRULE_shared_atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-7)&-(0x1f+1)) == 0 && ((1<<uint((_la-7)))&((1<<(PCREParserControlChar-7))|(1<<(PCREParserDecimalDigit-7))|(1<<(PCREParserNotDecimalDigit-7))|(1<<(PCREParserHorizontalWhiteSpace-7))|(1<<(PCREParserNotHorizontalWhiteSpace-7))|(1<<(PCREParserNotNewLine-7))|(1<<(PCREParserCharWithProperty-7))|(1<<(PCREParserCharWithoutProperty-7))|(1<<(PCREParserNewLineSequence-7))|(1<<(PCREParserWhiteSpace-7))|(1<<(PCREParserNotWhiteSpace-7))|(1<<(PCREParserVerticalWhiteSpace-7))|(1<<(PCREParserNotVerticalWhiteSpace-7))|(1<<(PCREParserWordChar-7))|(1<<(PCREParserNotWordChar-7))|(1<<(PCREParserPOSIXNamedSet-7))|(1<<(PCREParserPOSIXNegatedNamedSet-7)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) Shared_literal() IShared_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShared_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShared_literalContext)
}

func (s *LiteralContext) CharacterClassEnd() antlr.TerminalNode {
	return s.GetToken(PCREParserCharacterClassEnd, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PCREParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(850)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserQuoted, PCREParserBlockQuoted, PCREParserBellChar, PCREParserEscapeChar, PCREParserFormFeed, PCREParserNewLine, PCREParserCarriageReturn, PCREParserTab, PCREParserBackslash, PCREParserHexChar, PCREParserHyphen, PCREParserOpenBrace, PCREParserCloseBrace, PCREParserComma, PCREParserLessThan, PCREParserGreaterThan, PCREParserSingleQuote, PCREParserUnderscore, PCREParserColon, PCREParserHash, PCREParserEquals, PCREParserExclamation, PCREParserAmpersand, PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0, PCREParserOtherChar:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(848)
			p.Shared_literal()
		}

	case PCREParserCharacterClassEnd:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(849)
			p.Match(PCREParserCharacterClassEnd)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICc_literalContext is an interface to support dynamic dispatch.
type ICc_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCc_literalContext differentiates from other interfaces.
	IsCc_literalContext()
}

type Cc_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCc_literalContext() *Cc_literalContext {
	var p = new(Cc_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_cc_literal
	return p
}

func (*Cc_literalContext) IsCc_literalContext() {}

func NewCc_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cc_literalContext {
	var p = new(Cc_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_cc_literal

	return p
}

func (s *Cc_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Cc_literalContext) Shared_literal() IShared_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShared_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShared_literalContext)
}

func (s *Cc_literalContext) Dot() antlr.TerminalNode {
	return s.GetToken(PCREParserDot, 0)
}

func (s *Cc_literalContext) CharacterClassStart() antlr.TerminalNode {
	return s.GetToken(PCREParserCharacterClassStart, 0)
}

func (s *Cc_literalContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *Cc_literalContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Cc_literalContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *Cc_literalContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *Cc_literalContext) WordBoundary() antlr.TerminalNode {
	return s.GetToken(PCREParserWordBoundary, 0)
}

func (s *Cc_literalContext) EndOfSubjectOrLine() antlr.TerminalNode {
	return s.GetToken(PCREParserEndOfSubjectOrLine, 0)
}

func (s *Cc_literalContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, 0)
}

func (s *Cc_literalContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Cc_literalContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Cc_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cc_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cc_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCc_literal(s)
	}
}

func (s *Cc_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCc_literal(s)
	}
}

func (s *Cc_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCc_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Cc_literal() (localctx ICc_literalContext) {
	localctx = NewCc_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PCREParserRULE_cc_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(864)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserQuoted, PCREParserBlockQuoted, PCREParserBellChar, PCREParserEscapeChar, PCREParserFormFeed, PCREParserNewLine, PCREParserCarriageReturn, PCREParserTab, PCREParserBackslash, PCREParserHexChar, PCREParserHyphen, PCREParserOpenBrace, PCREParserCloseBrace, PCREParserComma, PCREParserLessThan, PCREParserGreaterThan, PCREParserSingleQuote, PCREParserUnderscore, PCREParserColon, PCREParserHash, PCREParserEquals, PCREParserExclamation, PCREParserAmpersand, PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0, PCREParserOtherChar:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(852)
			p.Shared_literal()
		}

	case PCREParserDot:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(853)
			p.Match(PCREParserDot)
		}

	case PCREParserCharacterClassStart:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(854)
			p.Match(PCREParserCharacterClassStart)
		}

	case PCREParserCaret:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(855)
			p.Match(PCREParserCaret)
		}

	case PCREParserQuestionMark:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(856)
			p.Match(PCREParserQuestionMark)
		}

	case PCREParserPlus:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(857)
			p.Match(PCREParserPlus)
		}

	case PCREParserStar:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(858)
			p.Match(PCREParserStar)
		}

	case PCREParserWordBoundary:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(859)
			p.Match(PCREParserWordBoundary)
		}

	case PCREParserEndOfSubjectOrLine:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(860)
			p.Match(PCREParserEndOfSubjectOrLine)
		}

	case PCREParserPipe:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(861)
			p.Match(PCREParserPipe)
		}

	case PCREParserOpenParen:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(862)
			p.Match(PCREParserOpenParen)
		}

	case PCREParserCloseParen:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(863)
			p.Match(PCREParserCloseParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShared_literalContext is an interface to support dynamic dispatch.
type IShared_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShared_literalContext differentiates from other interfaces.
	IsShared_literalContext()
}

type Shared_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShared_literalContext() *Shared_literalContext {
	var p = new(Shared_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_shared_literal
	return p
}

func (*Shared_literalContext) IsShared_literalContext() {}

func NewShared_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shared_literalContext {
	var p = new(Shared_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_shared_literal

	return p
}

func (s *Shared_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Shared_literalContext) Octal_char() IOctal_charContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctal_charContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctal_charContext)
}

func (s *Shared_literalContext) Letter() ILetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *Shared_literalContext) Digit() IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Shared_literalContext) BellChar() antlr.TerminalNode {
	return s.GetToken(PCREParserBellChar, 0)
}

func (s *Shared_literalContext) EscapeChar() antlr.TerminalNode {
	return s.GetToken(PCREParserEscapeChar, 0)
}

func (s *Shared_literalContext) FormFeed() antlr.TerminalNode {
	return s.GetToken(PCREParserFormFeed, 0)
}

func (s *Shared_literalContext) NewLine() antlr.TerminalNode {
	return s.GetToken(PCREParserNewLine, 0)
}

func (s *Shared_literalContext) CarriageReturn() antlr.TerminalNode {
	return s.GetToken(PCREParserCarriageReturn, 0)
}

func (s *Shared_literalContext) Tab() antlr.TerminalNode {
	return s.GetToken(PCREParserTab, 0)
}

func (s *Shared_literalContext) HexChar() antlr.TerminalNode {
	return s.GetToken(PCREParserHexChar, 0)
}

func (s *Shared_literalContext) Quoted() antlr.TerminalNode {
	return s.GetToken(PCREParserQuoted, 0)
}

func (s *Shared_literalContext) BlockQuoted() antlr.TerminalNode {
	return s.GetToken(PCREParserBlockQuoted, 0)
}

func (s *Shared_literalContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenBrace, 0)
}

func (s *Shared_literalContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseBrace, 0)
}

func (s *Shared_literalContext) Comma() antlr.TerminalNode {
	return s.GetToken(PCREParserComma, 0)
}

func (s *Shared_literalContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *Shared_literalContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *Shared_literalContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *Shared_literalContext) SingleQuote() antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, 0)
}

func (s *Shared_literalContext) Underscore() antlr.TerminalNode {
	return s.GetToken(PCREParserUnderscore, 0)
}

func (s *Shared_literalContext) Colon() antlr.TerminalNode {
	return s.GetToken(PCREParserColon, 0)
}

func (s *Shared_literalContext) Hash() antlr.TerminalNode {
	return s.GetToken(PCREParserHash, 0)
}

func (s *Shared_literalContext) Equals() antlr.TerminalNode {
	return s.GetToken(PCREParserEquals, 0)
}

func (s *Shared_literalContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(PCREParserExclamation, 0)
}

func (s *Shared_literalContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PCREParserAmpersand, 0)
}

func (s *Shared_literalContext) OtherChar() antlr.TerminalNode {
	return s.GetToken(PCREParserOtherChar, 0)
}

func (s *Shared_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shared_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shared_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterShared_literal(s)
	}
}

func (s *Shared_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitShared_literal(s)
	}
}

func (s *Shared_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitShared_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Shared_literal() (localctx IShared_literalContext) {
	localctx = NewShared_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PCREParserRULE_shared_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(892)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserBackslash:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(866)
			p.Octal_char()
		}

	case PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(867)
			p.Letter()
		}

	case PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(868)
			p.Digit()
		}

	case PCREParserBellChar:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(869)
			p.Match(PCREParserBellChar)
		}

	case PCREParserEscapeChar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(870)
			p.Match(PCREParserEscapeChar)
		}

	case PCREParserFormFeed:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(871)
			p.Match(PCREParserFormFeed)
		}

	case PCREParserNewLine:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(872)
			p.Match(PCREParserNewLine)
		}

	case PCREParserCarriageReturn:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(873)
			p.Match(PCREParserCarriageReturn)
		}

	case PCREParserTab:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(874)
			p.Match(PCREParserTab)
		}

	case PCREParserHexChar:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(875)
			p.Match(PCREParserHexChar)
		}

	case PCREParserQuoted:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(876)
			p.Match(PCREParserQuoted)
		}

	case PCREParserBlockQuoted:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(877)
			p.Match(PCREParserBlockQuoted)
		}

	case PCREParserOpenBrace:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(878)
			p.Match(PCREParserOpenBrace)
		}

	case PCREParserCloseBrace:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(879)
			p.Match(PCREParserCloseBrace)
		}

	case PCREParserComma:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(880)
			p.Match(PCREParserComma)
		}

	case PCREParserHyphen:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(881)
			p.Match(PCREParserHyphen)
		}

	case PCREParserLessThan:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(882)
			p.Match(PCREParserLessThan)
		}

	case PCREParserGreaterThan:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(883)
			p.Match(PCREParserGreaterThan)
		}

	case PCREParserSingleQuote:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(884)
			p.Match(PCREParserSingleQuote)
		}

	case PCREParserUnderscore:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(885)
			p.Match(PCREParserUnderscore)
		}

	case PCREParserColon:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(886)
			p.Match(PCREParserColon)
		}

	case PCREParserHash:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(887)
			p.Match(PCREParserHash)
		}

	case PCREParserEquals:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(888)
			p.Match(PCREParserEquals)
		}

	case PCREParserExclamation:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(889)
			p.Match(PCREParserExclamation)
		}

	case PCREParserAmpersand:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(890)
			p.Match(PCREParserAmpersand)
		}

	case PCREParserOtherChar:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(891)
			p.Match(PCREParserOtherChar)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Digits() IDigitsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitsContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (s *NumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PCREParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(894)
		p.Digits()
	}

	return localctx
}

// IOctal_charContext is an interface to support dynamic dispatch.
type IOctal_charContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctal_charContext differentiates from other interfaces.
	IsOctal_charContext()
}

type Octal_charContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctal_charContext() *Octal_charContext {
	var p = new(Octal_charContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_octal_char
	return p
}

func (*Octal_charContext) IsOctal_charContext() {}

func NewOctal_charContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Octal_charContext {
	var p = new(Octal_charContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_octal_char

	return p
}

func (s *Octal_charContext) GetParser() antlr.Parser { return s.parser }

func (s *Octal_charContext) Backslash() antlr.TerminalNode {
	return s.GetToken(PCREParserBackslash, 0)
}

func (s *Octal_charContext) AllOctal_digit() []IOctal_digitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOctal_digitContext)(nil)).Elem())
	var tst = make([]IOctal_digitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOctal_digitContext)
		}
	}

	return tst
}

func (s *Octal_charContext) Octal_digit(i int) IOctal_digitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctal_digitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOctal_digitContext)
}

func (s *Octal_charContext) D0() antlr.TerminalNode {
	return s.GetToken(PCREParserD0, 0)
}

func (s *Octal_charContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *Octal_charContext) D2() antlr.TerminalNode {
	return s.GetToken(PCREParserD2, 0)
}

func (s *Octal_charContext) D3() antlr.TerminalNode {
	return s.GetToken(PCREParserD3, 0)
}

func (s *Octal_charContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Octal_charContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Octal_charContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOctal_char(s)
	}
}

func (s *Octal_charContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOctal_char(s)
	}
}

func (s *Octal_charContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitOctal_char(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Octal_char() (localctx IOctal_charContext) {
	localctx = NewOctal_charContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PCREParserRULE_octal_char)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(905)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(896)
			p.Match(PCREParserBackslash)
		}
		{
			p.SetState(897)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(PCREParserD1-118))|(1<<(PCREParserD2-118))|(1<<(PCREParserD3-118))|(1<<(PCREParserD0-118)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(898)
			p.Octal_digit()
		}
		{
			p.SetState(899)
			p.Octal_digit()
		}

	case 2:
		{
			p.SetState(901)
			p.Match(PCREParserBackslash)
		}
		{
			p.SetState(902)
			p.Octal_digit()
		}
		{
			p.SetState(903)
			p.Octal_digit()
		}

	}

	return localctx
}

// IOctal_digitContext is an interface to support dynamic dispatch.
type IOctal_digitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctal_digitContext differentiates from other interfaces.
	IsOctal_digitContext()
}

type Octal_digitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctal_digitContext() *Octal_digitContext {
	var p = new(Octal_digitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_octal_digit
	return p
}

func (*Octal_digitContext) IsOctal_digitContext() {}

func NewOctal_digitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Octal_digitContext {
	var p = new(Octal_digitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_octal_digit

	return p
}

func (s *Octal_digitContext) GetParser() antlr.Parser { return s.parser }

func (s *Octal_digitContext) D0() antlr.TerminalNode {
	return s.GetToken(PCREParserD0, 0)
}

func (s *Octal_digitContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *Octal_digitContext) D2() antlr.TerminalNode {
	return s.GetToken(PCREParserD2, 0)
}

func (s *Octal_digitContext) D3() antlr.TerminalNode {
	return s.GetToken(PCREParserD3, 0)
}

func (s *Octal_digitContext) D4() antlr.TerminalNode {
	return s.GetToken(PCREParserD4, 0)
}

func (s *Octal_digitContext) D5() antlr.TerminalNode {
	return s.GetToken(PCREParserD5, 0)
}

func (s *Octal_digitContext) D6() antlr.TerminalNode {
	return s.GetToken(PCREParserD6, 0)
}

func (s *Octal_digitContext) D7() antlr.TerminalNode {
	return s.GetToken(PCREParserD7, 0)
}

func (s *Octal_digitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Octal_digitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Octal_digitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOctal_digit(s)
	}
}

func (s *Octal_digitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOctal_digit(s)
	}
}

func (s *Octal_digitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitOctal_digit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Octal_digit() (localctx IOctal_digitContext) {
	localctx = NewOctal_digitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PCREParserRULE_octal_digit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(PCREParserD1-118))|(1<<(PCREParserD2-118))|(1<<(PCREParserD3-118))|(1<<(PCREParserD4-118))|(1<<(PCREParserD5-118))|(1<<(PCREParserD6-118))|(1<<(PCREParserD7-118))|(1<<(PCREParserD0-118)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDigitsContext is an interface to support dynamic dispatch.
type IDigitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDigitsContext differentiates from other interfaces.
	IsDigitsContext()
}

type DigitsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitsContext() *DigitsContext {
	var p = new(DigitsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_digits
	return p
}

func (*DigitsContext) IsDigitsContext() {}

func NewDigitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitsContext {
	var p = new(DigitsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_digits

	return p
}

func (s *DigitsContext) GetParser() antlr.Parser { return s.parser }

func (s *DigitsContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *DigitsContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *DigitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterDigits(s)
	}
}

func (s *DigitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitDigits(s)
	}
}

func (s *DigitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitDigits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Digits() (localctx IDigitsContext) {
	localctx = NewDigitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PCREParserRULE_digits)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(909)
				p.Digit()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
	}

	return localctx
}

// IDigitContext is an interface to support dynamic dispatch.
type IDigitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDigitContext differentiates from other interfaces.
	IsDigitContext()
}

type DigitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitContext() *DigitContext {
	var p = new(DigitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_digit
	return p
}

func (*DigitContext) IsDigitContext() {}

func NewDigitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitContext {
	var p = new(DigitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_digit

	return p
}

func (s *DigitContext) GetParser() antlr.Parser { return s.parser }

func (s *DigitContext) D0() antlr.TerminalNode {
	return s.GetToken(PCREParserD0, 0)
}

func (s *DigitContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *DigitContext) D2() antlr.TerminalNode {
	return s.GetToken(PCREParserD2, 0)
}

func (s *DigitContext) D3() antlr.TerminalNode {
	return s.GetToken(PCREParserD3, 0)
}

func (s *DigitContext) D4() antlr.TerminalNode {
	return s.GetToken(PCREParserD4, 0)
}

func (s *DigitContext) D5() antlr.TerminalNode {
	return s.GetToken(PCREParserD5, 0)
}

func (s *DigitContext) D6() antlr.TerminalNode {
	return s.GetToken(PCREParserD6, 0)
}

func (s *DigitContext) D7() antlr.TerminalNode {
	return s.GetToken(PCREParserD7, 0)
}

func (s *DigitContext) D8() antlr.TerminalNode {
	return s.GetToken(PCREParserD8, 0)
}

func (s *DigitContext) D9() antlr.TerminalNode {
	return s.GetToken(PCREParserD9, 0)
}

func (s *DigitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterDigit(s)
	}
}

func (s *DigitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitDigit(s)
	}
}

func (s *DigitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitDigit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Digit() (localctx IDigitContext) {
	localctx = NewDigitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PCREParserRULE_digit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(PCREParserD1-118))|(1<<(PCREParserD2-118))|(1<<(PCREParserD3-118))|(1<<(PCREParserD4-118))|(1<<(PCREParserD5-118))|(1<<(PCREParserD6-118))|(1<<(PCREParserD7-118))|(1<<(PCREParserD8-118))|(1<<(PCREParserD9-118))|(1<<(PCREParserD0-118)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) Alpha_nums() IAlpha_numsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlpha_numsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlpha_numsContext)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PCREParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(916)
		p.Alpha_nums()
	}

	return localctx
}

// IAlpha_numsContext is an interface to support dynamic dispatch.
type IAlpha_numsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlpha_numsContext differentiates from other interfaces.
	IsAlpha_numsContext()
}

type Alpha_numsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlpha_numsContext() *Alpha_numsContext {
	var p = new(Alpha_numsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_alpha_nums
	return p
}

func (*Alpha_numsContext) IsAlpha_numsContext() {}

func NewAlpha_numsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alpha_numsContext {
	var p = new(Alpha_numsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_alpha_nums

	return p
}

func (s *Alpha_numsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alpha_numsContext) AllLetter() []ILetterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILetterContext)(nil)).Elem())
	var tst = make([]ILetterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILetterContext)
		}
	}

	return tst
}

func (s *Alpha_numsContext) Letter(i int) ILetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *Alpha_numsContext) AllUnderscore() []antlr.TerminalNode {
	return s.GetTokens(PCREParserUnderscore)
}

func (s *Alpha_numsContext) Underscore(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserUnderscore, i)
}

func (s *Alpha_numsContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *Alpha_numsContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Alpha_numsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alpha_numsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alpha_numsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAlpha_nums(s)
	}
}

func (s *Alpha_numsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAlpha_nums(s)
	}
}

func (s *Alpha_numsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAlpha_nums(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Alpha_nums() (localctx IAlpha_numsContext) {
	localctx = NewAlpha_numsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PCREParserRULE_alpha_nums)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(920)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC:
		{
			p.SetState(918)
			p.Letter()
		}

	case PCREParserUnderscore:
		{
			p.SetState(919)
			p.Match(PCREParserUnderscore)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(927)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(925)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC:
				{
					p.SetState(922)
					p.Letter()
				}

			case PCREParserUnderscore:
				{
					p.SetState(923)
					p.Match(PCREParserUnderscore)
				}

			case PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0:
				{
					p.SetState(924)
					p.Digit()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
	}

	return localctx
}

// INon_close_parensContext is an interface to support dynamic dispatch.
type INon_close_parensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_close_parensContext differentiates from other interfaces.
	IsNon_close_parensContext()
}

type Non_close_parensContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_close_parensContext() *Non_close_parensContext {
	var p = new(Non_close_parensContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_non_close_parens
	return p
}

func (*Non_close_parensContext) IsNon_close_parensContext() {}

func NewNon_close_parensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_close_parensContext {
	var p = new(Non_close_parensContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_non_close_parens

	return p
}

func (s *Non_close_parensContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_close_parensContext) AllNon_close_paren() []INon_close_parenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INon_close_parenContext)(nil)).Elem())
	var tst = make([]INon_close_parenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INon_close_parenContext)
		}
	}

	return tst
}

func (s *Non_close_parensContext) Non_close_paren(i int) INon_close_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_close_parenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INon_close_parenContext)
}

func (s *Non_close_parensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_close_parensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_close_parensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNon_close_parens(s)
	}
}

func (s *Non_close_parensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNon_close_parens(s)
	}
}

func (s *Non_close_parensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitNon_close_parens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Non_close_parens() (localctx INon_close_parensContext) {
	localctx = NewNon_close_parensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PCREParserRULE_non_close_parens)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-1)&-(0x1f+1)) == 0 && ((1<<uint((_la-1)))&((1<<(PCREParserT__0-1))|(1<<(PCREParserT__1-1))|(1<<(PCREParserT__2-1))|(1<<(PCREParserQuoted-1))|(1<<(PCREParserBlockQuoted-1))|(1<<(PCREParserBellChar-1))|(1<<(PCREParserControlChar-1))|(1<<(PCREParserEscapeChar-1))|(1<<(PCREParserFormFeed-1))|(1<<(PCREParserNewLine-1))|(1<<(PCREParserCarriageReturn-1))|(1<<(PCREParserTab-1))|(1<<(PCREParserBackslash-1))|(1<<(PCREParserHexChar-1))|(1<<(PCREParserDot-1))|(1<<(PCREParserOneDataUnit-1))|(1<<(PCREParserDecimalDigit-1))|(1<<(PCREParserNotDecimalDigit-1))|(1<<(PCREParserHorizontalWhiteSpace-1))|(1<<(PCREParserNotHorizontalWhiteSpace-1))|(1<<(PCREParserNotNewLine-1))|(1<<(PCREParserCharWithProperty-1))|(1<<(PCREParserCharWithoutProperty-1))|(1<<(PCREParserNewLineSequence-1))|(1<<(PCREParserWhiteSpace-1))|(1<<(PCREParserNotWhiteSpace-1))|(1<<(PCREParserVerticalWhiteSpace-1))|(1<<(PCREParserNotVerticalWhiteSpace-1))|(1<<(PCREParserWordChar-1))|(1<<(PCREParserNotWordChar-1))|(1<<(PCREParserExtendedUnicodeChar-1))|(1<<(PCREParserCharacterClassStart-1)))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(PCREParserCharacterClassEnd-33))|(1<<(PCREParserCaret-33))|(1<<(PCREParserHyphen-33))|(1<<(PCREParserPOSIXNamedSet-33))|(1<<(PCREParserPOSIXNegatedNamedSet-33))|(1<<(PCREParserQuestionMark-33))|(1<<(PCREParserPlus-33))|(1<<(PCREParserStar-33))|(1<<(PCREParserOpenBrace-33))|(1<<(PCREParserCloseBrace-33))|(1<<(PCREParserComma-33))|(1<<(PCREParserWordBoundary-33))|(1<<(PCREParserNonWordBoundary-33))|(1<<(PCREParserStartOfSubject-33))|(1<<(PCREParserEndOfSubjectOrLine-33))|(1<<(PCREParserEndOfSubjectOrLineEndOfSubject-33))|(1<<(PCREParserEndOfSubject-33))|(1<<(PCREParserPreviousMatchInSubject-33))|(1<<(PCREParserResetStartMatch-33))|(1<<(PCREParserSubroutineOrNamedReferenceStartG-33))|(1<<(PCREParserNamedReferenceStartK-33))|(1<<(PCREParserPipe-33))|(1<<(PCREParserOpenParen-33))|(1<<(PCREParserLessThan-33))|(1<<(PCREParserGreaterThan-33))|(1<<(PCREParserSingleQuote-33))|(1<<(PCREParserUnderscore-33))|(1<<(PCREParserColon-33))|(1<<(PCREParserHash-33))|(1<<(PCREParserEquals-33))|(1<<(PCREParserExclamation-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(PCREParserAmpersand-65))|(1<<(PCREParserALC-65))|(1<<(PCREParserBLC-65))|(1<<(PCREParserCLC-65))|(1<<(PCREParserDLC-65))|(1<<(PCREParserELC-65))|(1<<(PCREParserFLC-65))|(1<<(PCREParserGLC-65))|(1<<(PCREParserHLC-65))|(1<<(PCREParserILC-65))|(1<<(PCREParserJLC-65))|(1<<(PCREParserKLC-65))|(1<<(PCREParserLLC-65))|(1<<(PCREParserMLC-65))|(1<<(PCREParserNLC-65))|(1<<(PCREParserOLC-65))|(1<<(PCREParserPLC-65))|(1<<(PCREParserQLC-65))|(1<<(PCREParserRLC-65))|(1<<(PCREParserSLC-65))|(1<<(PCREParserTLC-65))|(1<<(PCREParserULC-65))|(1<<(PCREParserVLC-65))|(1<<(PCREParserWLC-65))|(1<<(PCREParserXLC-65))|(1<<(PCREParserYLC-65))|(1<<(PCREParserZLC-65))|(1<<(PCREParserAUC-65))|(1<<(PCREParserBUC-65))|(1<<(PCREParserCUC-65))|(1<<(PCREParserDUC-65))|(1<<(PCREParserEUC-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(PCREParserFUC-97))|(1<<(PCREParserGUC-97))|(1<<(PCREParserHUC-97))|(1<<(PCREParserIUC-97))|(1<<(PCREParserJUC-97))|(1<<(PCREParserKUC-97))|(1<<(PCREParserLUC-97))|(1<<(PCREParserMUC-97))|(1<<(PCREParserNUC-97))|(1<<(PCREParserOUC-97))|(1<<(PCREParserPUC-97))|(1<<(PCREParserQUC-97))|(1<<(PCREParserRUC-97))|(1<<(PCREParserSUC-97))|(1<<(PCREParserTUC-97))|(1<<(PCREParserUUC-97))|(1<<(PCREParserVUC-97))|(1<<(PCREParserWUC-97))|(1<<(PCREParserXUC-97))|(1<<(PCREParserYUC-97))|(1<<(PCREParserZUC-97))|(1<<(PCREParserD1-97))|(1<<(PCREParserD2-97))|(1<<(PCREParserD3-97))|(1<<(PCREParserD4-97))|(1<<(PCREParserD5-97))|(1<<(PCREParserD6-97))|(1<<(PCREParserD7-97))|(1<<(PCREParserD8-97))|(1<<(PCREParserD9-97))|(1<<(PCREParserD0-97))|(1<<(PCREParserOtherChar-97)))) != 0) {
		{
			p.SetState(930)
			p.Non_close_paren()
		}

		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INon_close_parenContext is an interface to support dynamic dispatch.
type INon_close_parenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_close_parenContext differentiates from other interfaces.
	IsNon_close_parenContext()
}

type Non_close_parenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_close_parenContext() *Non_close_parenContext {
	var p = new(Non_close_parenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_non_close_paren
	return p
}

func (*Non_close_parenContext) IsNon_close_parenContext() {}

func NewNon_close_parenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_close_parenContext {
	var p = new(Non_close_parenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_non_close_paren

	return p
}

func (s *Non_close_parenContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_close_parenContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Non_close_parenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_close_parenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_close_parenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNon_close_paren(s)
	}
}

func (s *Non_close_parenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNon_close_paren(s)
	}
}

func (s *Non_close_parenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitNon_close_paren(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Non_close_paren() (localctx INon_close_parenContext) {
	localctx = NewNon_close_parenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PCREParserRULE_non_close_paren)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || _la == PCREParserCloseParen {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILetterContext is an interface to support dynamic dispatch.
type ILetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLetterContext differentiates from other interfaces.
	IsLetterContext()
}

type LetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetterContext() *LetterContext {
	var p = new(LetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_letter
	return p
}

func (*LetterContext) IsLetterContext() {}

func NewLetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetterContext {
	var p = new(LetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_letter

	return p
}

func (s *LetterContext) GetParser() antlr.Parser { return s.parser }

func (s *LetterContext) ALC() antlr.TerminalNode {
	return s.GetToken(PCREParserALC, 0)
}

func (s *LetterContext) BLC() antlr.TerminalNode {
	return s.GetToken(PCREParserBLC, 0)
}

func (s *LetterContext) CLC() antlr.TerminalNode {
	return s.GetToken(PCREParserCLC, 0)
}

func (s *LetterContext) DLC() antlr.TerminalNode {
	return s.GetToken(PCREParserDLC, 0)
}

func (s *LetterContext) ELC() antlr.TerminalNode {
	return s.GetToken(PCREParserELC, 0)
}

func (s *LetterContext) FLC() antlr.TerminalNode {
	return s.GetToken(PCREParserFLC, 0)
}

func (s *LetterContext) GLC() antlr.TerminalNode {
	return s.GetToken(PCREParserGLC, 0)
}

func (s *LetterContext) HLC() antlr.TerminalNode {
	return s.GetToken(PCREParserHLC, 0)
}

func (s *LetterContext) ILC() antlr.TerminalNode {
	return s.GetToken(PCREParserILC, 0)
}

func (s *LetterContext) JLC() antlr.TerminalNode {
	return s.GetToken(PCREParserJLC, 0)
}

func (s *LetterContext) KLC() antlr.TerminalNode {
	return s.GetToken(PCREParserKLC, 0)
}

func (s *LetterContext) LLC() antlr.TerminalNode {
	return s.GetToken(PCREParserLLC, 0)
}

func (s *LetterContext) MLC() antlr.TerminalNode {
	return s.GetToken(PCREParserMLC, 0)
}

func (s *LetterContext) NLC() antlr.TerminalNode {
	return s.GetToken(PCREParserNLC, 0)
}

func (s *LetterContext) OLC() antlr.TerminalNode {
	return s.GetToken(PCREParserOLC, 0)
}

func (s *LetterContext) PLC() antlr.TerminalNode {
	return s.GetToken(PCREParserPLC, 0)
}

func (s *LetterContext) QLC() antlr.TerminalNode {
	return s.GetToken(PCREParserQLC, 0)
}

func (s *LetterContext) RLC() antlr.TerminalNode {
	return s.GetToken(PCREParserRLC, 0)
}

func (s *LetterContext) SLC() antlr.TerminalNode {
	return s.GetToken(PCREParserSLC, 0)
}

func (s *LetterContext) TLC() antlr.TerminalNode {
	return s.GetToken(PCREParserTLC, 0)
}

func (s *LetterContext) ULC() antlr.TerminalNode {
	return s.GetToken(PCREParserULC, 0)
}

func (s *LetterContext) VLC() antlr.TerminalNode {
	return s.GetToken(PCREParserVLC, 0)
}

func (s *LetterContext) WLC() antlr.TerminalNode {
	return s.GetToken(PCREParserWLC, 0)
}

func (s *LetterContext) XLC() antlr.TerminalNode {
	return s.GetToken(PCREParserXLC, 0)
}

func (s *LetterContext) YLC() antlr.TerminalNode {
	return s.GetToken(PCREParserYLC, 0)
}

func (s *LetterContext) ZLC() antlr.TerminalNode {
	return s.GetToken(PCREParserZLC, 0)
}

func (s *LetterContext) AUC() antlr.TerminalNode {
	return s.GetToken(PCREParserAUC, 0)
}

func (s *LetterContext) BUC() antlr.TerminalNode {
	return s.GetToken(PCREParserBUC, 0)
}

func (s *LetterContext) CUC() antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, 0)
}

func (s *LetterContext) DUC() antlr.TerminalNode {
	return s.GetToken(PCREParserDUC, 0)
}

func (s *LetterContext) EUC() antlr.TerminalNode {
	return s.GetToken(PCREParserEUC, 0)
}

func (s *LetterContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *LetterContext) GUC() antlr.TerminalNode {
	return s.GetToken(PCREParserGUC, 0)
}

func (s *LetterContext) HUC() antlr.TerminalNode {
	return s.GetToken(PCREParserHUC, 0)
}

func (s *LetterContext) IUC() antlr.TerminalNode {
	return s.GetToken(PCREParserIUC, 0)
}

func (s *LetterContext) JUC() antlr.TerminalNode {
	return s.GetToken(PCREParserJUC, 0)
}

func (s *LetterContext) KUC() antlr.TerminalNode {
	return s.GetToken(PCREParserKUC, 0)
}

func (s *LetterContext) LUC() antlr.TerminalNode {
	return s.GetToken(PCREParserLUC, 0)
}

func (s *LetterContext) MUC() antlr.TerminalNode {
	return s.GetToken(PCREParserMUC, 0)
}

func (s *LetterContext) NUC() antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, 0)
}

func (s *LetterContext) OUC() antlr.TerminalNode {
	return s.GetToken(PCREParserOUC, 0)
}

func (s *LetterContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *LetterContext) QUC() antlr.TerminalNode {
	return s.GetToken(PCREParserQUC, 0)
}

func (s *LetterContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *LetterContext) SUC() antlr.TerminalNode {
	return s.GetToken(PCREParserSUC, 0)
}

func (s *LetterContext) TUC() antlr.TerminalNode {
	return s.GetToken(PCREParserTUC, 0)
}

func (s *LetterContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *LetterContext) VUC() antlr.TerminalNode {
	return s.GetToken(PCREParserVUC, 0)
}

func (s *LetterContext) WUC() antlr.TerminalNode {
	return s.GetToken(PCREParserWUC, 0)
}

func (s *LetterContext) XUC() antlr.TerminalNode {
	return s.GetToken(PCREParserXUC, 0)
}

func (s *LetterContext) YUC() antlr.TerminalNode {
	return s.GetToken(PCREParserYUC, 0)
}

func (s *LetterContext) ZUC() antlr.TerminalNode {
	return s.GetToken(PCREParserZUC, 0)
}

func (s *LetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLetter(s)
	}
}

func (s *LetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLetter(s)
	}
}

func (s *LetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitLetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Letter() (localctx ILetterContext) {
	localctx = NewLetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PCREParserRULE_letter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(PCREParserALC-66))|(1<<(PCREParserBLC-66))|(1<<(PCREParserCLC-66))|(1<<(PCREParserDLC-66))|(1<<(PCREParserELC-66))|(1<<(PCREParserFLC-66))|(1<<(PCREParserGLC-66))|(1<<(PCREParserHLC-66))|(1<<(PCREParserILC-66))|(1<<(PCREParserJLC-66))|(1<<(PCREParserKLC-66))|(1<<(PCREParserLLC-66))|(1<<(PCREParserMLC-66))|(1<<(PCREParserNLC-66))|(1<<(PCREParserOLC-66))|(1<<(PCREParserPLC-66))|(1<<(PCREParserQLC-66))|(1<<(PCREParserRLC-66))|(1<<(PCREParserSLC-66))|(1<<(PCREParserTLC-66))|(1<<(PCREParserULC-66))|(1<<(PCREParserVLC-66))|(1<<(PCREParserWLC-66))|(1<<(PCREParserXLC-66))|(1<<(PCREParserYLC-66))|(1<<(PCREParserZLC-66))|(1<<(PCREParserAUC-66))|(1<<(PCREParserBUC-66))|(1<<(PCREParserCUC-66))|(1<<(PCREParserDUC-66))|(1<<(PCREParserEUC-66))|(1<<(PCREParserFUC-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(PCREParserGUC-98))|(1<<(PCREParserHUC-98))|(1<<(PCREParserIUC-98))|(1<<(PCREParserJUC-98))|(1<<(PCREParserKUC-98))|(1<<(PCREParserLUC-98))|(1<<(PCREParserMUC-98))|(1<<(PCREParserNUC-98))|(1<<(PCREParserOUC-98))|(1<<(PCREParserPUC-98))|(1<<(PCREParserQUC-98))|(1<<(PCREParserRUC-98))|(1<<(PCREParserSUC-98))|(1<<(PCREParserTUC-98))|(1<<(PCREParserUUC-98))|(1<<(PCREParserVUC-98))|(1<<(PCREParserWUC-98))|(1<<(PCREParserXUC-98))|(1<<(PCREParserYUC-98))|(1<<(PCREParserZUC-98)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
